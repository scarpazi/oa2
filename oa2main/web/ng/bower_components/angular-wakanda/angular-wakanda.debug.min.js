/*! angular-wakanda - v1.0.2 - 2015-12-16 */
(function(exports, global) {
    global["true"] = exports;
    var Class;
    (function() {
        var initializing = false, fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;
        Class = function() {};
        Class.extend = function(prop) {
            var _super = this.prototype;
            initializing = true;
            var prototype = new this();
            initializing = false;
            for (var name in prop) prototype[name] = "function" == typeof prop[name] && "function" == typeof _super[name] && fnTest.test(prop[name]) ? function(name, fn) {
                return function() {
                    var tmp = this._super;
                    this._super = _super[name];
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            }(name, prop[name]) : prop[name];
            function Class() {
                if (!initializing && this.init) this.init.apply(this, arguments);
            }
            Class.prototype = prototype;
            Class.prototype.constructor = Class;
            Class.extend = arguments.callee;
            return Class;
        };
    })();
    var WAF = {
        core: {},
        config: {}
    };
    function ISOToDate(string) {
        var dd = new Date();
        dd.setISO(string);
        return dd;
    }
    function stringToSimpleDate(string) {
        if (null == string || "" == string) return null;
        var arr = string.split("!");
        if (arr.length < 3) return null;
        return new Date(Number(arr[2]), Number(arr[1]) - 1, Number(arr[0]));
    }
    Date.prototype.toJSON = function(key) {
        return this.toISO() + "," + this.toSimpleDateString();
    };
    Date.prototype.toSimpleDateString = function() {
        return "" + this.getDate() + "!" + (this.getMonth() + 1) + "!" + (this.getYear() + 1900);
    };
    Date.prototype.setISO = function(string) {
        var regexp = "([0-9]{4})(-([0-9]{2})(-([0-9]{2})" + "(T([0-9]{2}):([0-9]{2})(:([0-9]{2})(.([0-9]+))?)?" + "(Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?";
        var d = string.match(new RegExp(regexp));
        var offset = 0;
        var date = new Date(d[1], 0, 1);
        if (d[3]) date.setMonth(d[3] - 1);
        if (d[5]) date.setDate(d[5]);
        if (d[7]) date.setHours(d[7]);
        if (d[8]) date.setMinutes(d[8]);
        if (d[10]) date.setSeconds(d[10]);
        if (d[12]) date.setMilliseconds(1e3 * Number("0." + d[12]));
        if (d[14]) {
            offset = 60 * Number(d[16]) + Number(d[17]);
            offset *= "-" == d[15] ? 1 : -1;
        }
        offset -= date.getTimezoneOffset();
        time = Number(date) + 60 * offset * 1e3;
        this.setTime(Number(time));
    };
    Date.prototype.toISO = function(format, offset) {
        if (!format) var format = 6;
        if (!offset) {
            var offset = "Z";
            var date = this;
        } else {
            var d = offset.match(/([-+])([0-9]{2}):([0-9]{2})/);
            var offsetnum = 60 * Number(d[2]) + Number(d[3]);
            offsetnum *= "-" == d[1] ? -1 : 1;
            var date = new Date(Number(Number(this) + 6e4 * offsetnum));
        }
        var zeropad = function(num) {
            return (num < 10 ? "0" : "") + num;
        };
        var str = "";
        str += date.getUTCFullYear();
        if (format > 1) str += "-" + zeropad(date.getUTCMonth() + 1);
        if (format > 2) str += "-" + zeropad(date.getUTCDate());
        if (format > 3) str += "T" + zeropad(date.getUTCHours()) + ":" + zeropad(date.getUTCMinutes());
        if (format > 5) {
            var secs = Number(date.getUTCSeconds() + "." + (date.getUTCMilliseconds() < 100 ? "0" : "") + zeropad(date.getUTCMilliseconds()));
            str += ":" + zeropad(secs);
        } else if (format > 4) str += ":" + zeropad(date.getUTCSeconds());
        if (format > 3) str += offset;
        return str;
    };
    Date.prototype.isValid = function() {
        return !isNaN(this.getTime());
    };
    WAF.core.restConnect = {};
    WAF.core.restConnect.httpMethods = {
        _post: "POST",
        _get: "GET",
        _put: "PUT",
        _delete: "DELETE"
    };
    WAF.core.restConnect.restActions = {
        _retrieve: "retrieve",
        _create: "create",
        _update: "update",
        _delete: "delete"
    };
    WAF.core.restConnect.queryOptions = {
        _expand: "$expand",
        _orderby: "$orderby",
        _skip: "$skip",
        _top: "$top",
        _filter: "$filter"
    };
    WAF.core.restConnect.filterOperators = {
        _equal: "eq",
        _notequal: "neq",
        _greaterthan: "gt",
        _greaterthanorequal: "gteq",
        _lessthan: "lt",
        _lessthanorequal: "lteq",
        _logicaland: "and",
        _logicalor: "or",
        _logicalnot: "not"
    };
    WAF.core.restConnect.filterArithmeticOperators = {
        _add: "add",
        _sub: "sub",
        _mul: "mul",
        _div: "div",
        _mod: "mod"
    };
    WAF.core.restConnect.defaultService = "rest";
    WAF.core.restConnect.standardErrors = {
        _hostnamemissing: {
            key: "1",
            string: "The hostname is missing."
        },
        _servicemissing: {
            key: "2",
            string: "The service is missing."
        },
        _httpmethodundefined: {
            key: "3",
            string: "The HTTP method is undefined."
        },
        _wronghttpmethod: {
            key: "4",
            string: "The HTTP method get doesn't support POST data."
        }
    };
    WAF.core.restConnect.getXMLHttpRequest = function() {
        var http_request = false;
        if (window.XMLHttpRequest) http_request = new XMLHttpRequest(); else if (window.ActiveXObject) ;
        return http_request;
    };
    WAF.core.restConnect.restRequest = function(connectionMode) {
        this.connectionMode = connectionMode;
        this.fullURL = null;
        this.httpMethod = WAF.core.restConnect.httpMethods._get;
        this.hostname = "";
        this.app = WAF.config.pattern;
        this.service = WAF.core.restConnect.defaultService;
        this.resource = "";
        this.attributesRequested = void 0;
        this.keys = [];
        this.expand = [];
        this.orderby = [];
        this.skip = null;
        this.top = null;
        this.filter = null;
        this.method = null;
        this.metadata = null;
        this.handler = null;
        this.postdata = null;
        this.postAFile = false;
        this.queryPlan = null;
        this.progressInfo = null;
        this.distinct = false;
        this.refreshOnly = false;
        this.error = {
            key: 0,
            string: ""
        };
        this.orderByArgsToString = function() {
            var retString = "";
            if ("string" === typeof this.orderby) return this.orderby;
            if (this.orderby.length > 0) retString = this.orderby[0];
            for (var i = 1; i < this.orderby.length; i++) retString += "," + this.orderby[i];
            return retString;
        };
        this.go = function(options) {
            var handler = this.handler;
            var url = (WAF.hostname ? WAF.hostname : "") + "/";
            if (null != this.app) url = this.app + "/";
            if ("" !== this.service) url += this.service + "/"; else {
                this.error = WAF.core.restConnect.standardErrors._servicemissing;
                return false;
            }
            if ("" !== this.resource) {
                url += this.resource + "/";
                if (this.keys.length > 0) {
                    url += "(";
                    for (var i = 0; i < this.keys.length; i++) {
                        url += this.keys[i];
                        if (i < this.keys.length - 1) url += ",";
                    }
                    url += ")";
                }
            }
            var deja$ = false;
            if (this.dataURI) {
                url = this.dataURI;
                deja$ = url.indexOf("?") !== -1;
                if (!deja$) url += "/";
            }
            var needToAddQuaestionMark = !deja$;
            if (void 0 != this.attributesRequested) {
                if (this.attributesRequested.length > 0) {
                    url += this.attributesRequested[0];
                    for (var i = 1; i < this.attributesRequested.length; i++) url += "," + this.attributesRequested[i];
                }
                url += "/";
            }
            var queryString = "";
            if (this.skip) {
                queryString += (!deja$ ? "$skip=" : "&$skip=") + this.skip;
                deja$ = true;
            }
            if (this.top) {
                queryString += (!deja$ ? "$top=" : "&$top=") + this.top;
                deja$ = true;
            }
            if (this.filter) {
                queryString += (!deja$ ? "$filter=" : "&$filter=") + encodeURIComponent("'" + this.filter + "'");
                deja$ = true;
            }
            if (this.params) {
                queryString += (!deja$ ? "$params=" : "&$params=") + encodeURIComponent("'" + JSON.stringify(this.params).replace(/'/g, "\\u0027") + "'");
                deja$ = true;
            }
            if (this.method) {
                queryString += (!deja$ ? "$method=" : "&$method=") + this.method;
                deja$ = true;
            }
            if (this.asArray) {
                queryString += (!deja$ ? "$asArray=" : "&$asArray=") + "true";
                deja$ = true;
            }
            if (this.metadata) {
                queryString += (!deja$ ? "$metadata=" : "&$metadata=") + this.metadata;
                deja$ = true;
            }
            if (null != this.mustlock) {
                queryString += (!deja$ ? "$lock=" : "&$lock=") + this.mustlock;
                deja$ = true;
            }
            if (this.distinct) {
                queryString += (!deja$ ? "$distinct=" : "&$distinct=") + this.distinct;
                deja$ = true;
            }
            if (null != this.findKey) {
                queryString += (!deja$ ? "$findKey=" : "&$findKey=") + encodeURIComponent("" + this.findKey);
                deja$ = true;
            }
            if (null != this.reselect) {
                queryString += (!deja$ ? "$reselect=" : "&$reselect=") + encodeURIComponent("" + this.reselect);
                deja$ = true;
            }
            if (this.queryPlan) {
                queryString += !deja$ ? "$queryplan=true&querypath=true" : "&$queryplan=true&querypath=true";
                deja$ = true;
            }
            if (this.progressInfo) {
                queryString += (!deja$ ? "$progressinfo=" : "&$progressinfo=") + encodeURIComponent(this.progressInfo);
                deja$ = true;
            }
            if (this.timeout) {
                queryString += (!deja$ ? "$timeout=" : "&$timeout=") + this.timeout;
                deja$ = true;
            }
            if (this.savedQueryString) {
                queryString += (!deja$ ? "$savedfilter=" : "&$savedfilter=") + encodeURIComponent("'" + this.savedQueryString + "'");
                deja$ = true;
            }
            if (this.savedOrderby) {
                queryString += (!deja$ ? "$savedorderby=" : "&$savedorderby=") + this.savedOrderby;
                deja$ = true;
            }
            if (this.refreshOnly) {
                queryString += (!deja$ ? "$refresh=" : "&$refresh=") + this.refreshOnly;
                deja$ = true;
            }
            if (this.atOnce) {
                queryString += (!deja$ ? "$atOnce=" : "&$atOnce=") + this.atOnce;
                deja$ = true;
            }
            if (this.postAFile) {
                queryString += !deja$ ? "$rawPict=true" : "&$rawPict=true";
                deja$ = true;
            }
            if (this.retainPositions) {
                queryString += (!deja$ ? "$retainPositions=" : "&$retainPositions=") + this.retainPositions;
                deja$ = true;
            }
            if (null != this.removeAtPos) {
                queryString += (!deja$ ? "$removeFromSet=" : "&$removeFromSet=") + this.removeAtPos;
                deja$ = true;
            }
            if (null != this.removeReferenceOnly) {
                queryString += (!deja$ ? "$removeRefOnly=" : "&$removeRefOnly=") + this.removeReferenceOnly;
                deja$ = true;
            }
            if (null != this.filterAttributes) {
                queryString += (!deja$ ? "$attributes=" : "&$attributes=") + encodeURIComponent(this.filterAttributes);
                deja$ = true;
            }
            if (null != this.addToSet) {
                queryString += (!deja$ ? "$addToSet=" : "&$addToSet=") + encodeURIComponent("'" + JSON.stringify(this.addToSet) + "'");
                deja$ = true;
            }
            if (null != this.fromSelection) {
                queryString += (!deja$ ? "$fromSel=" : "&$fromSel=") + encodeURIComponent("'" + JSON.stringify(this.fromSelection) + "'");
                deja$ = true;
            }
            if (null != this.keepSelection) {
                queryString += (!deja$ ? "$keepSel=" : "&$keepSel=") + encodeURIComponent("'" + JSON.stringify(this.keepSelection) + "'");
                deja$ = true;
            }
            if (this.orderby) if (this.orderby.length) {
                if (!deja$) queryString += "$orderby=" + this.orderByArgsToString(); else queryString += "&$orderby=" + this.orderByArgsToString();
                deja$ = true;
            }
            if (null != this.subOrderby) {
                queryString += (!deja$ ? "$subOrderby=" : "&$subOrderby=") + encodeURIComponent(this.subOrderby);
                deja$ = true;
            }
            if (void 0 != this.attributesExpanded) if (this.attributesExpanded.length > 0) {
                var expandString = "";
                if (!deja$) queryString += "$expand="; else queryString += "&$expand=";
                deja$ = true;
                for (var i = 0; i < this.attributesExpanded.length; i++) if ("" === expandString) expandString += this.attributesExpanded[i]; else expandString += "," + this.attributesExpanded[i];
                queryString += expandString;
            }
            if (null != this.autoExpand && "" != this.autoExpand) {
                if (!deja$) queryString += "$expand="; else queryString += "&$expand=";
                deja$ = true;
                queryString += this.autoExpand;
            }
            if (null != this.autoSubExpand && "" != this.autoSubExpand) {
                if (!deja$) queryString += "$subExpand="; else queryString += "&$subExpand=";
                deja$ = true;
                queryString += this.autoSubExpand;
            }
            if ("" !== queryString) {
                if (needToAddQuaestionMark) url += "?";
                url += queryString;
            }
            var command = "";
            if ("" !== this.httpMethod) command = this.httpMethod; else this.error = WAF.core.restConnect.httpMethods._get;
            if (this.postdata && command == WAF.core.restConnect.httpMethods._get) {
                this.error = WAF.core.restConnect.standardErrors._wronghttpmethod;
                return false;
            }
            this.http_request = WAF.core.restConnect.getXMLHttpRequest();
            if (!this.http_request) return;
            this.http_request.parent = this;
            if (options && options.generateRESTRequestOnly) return url; else {
                if (null != handler) this.http_request.onreadystatechange = function() {
                    handler(this.parent);
                };
                try {
                    if (this.fullURL) url = this.fullURL;
                    this.http_request.open(command, url, this.connectionMode);
                    if (this.postdata) if (this.postAFile) this.http_request.setRequestHeader("Content-Type", this.postdata.type); else this.http_request.setRequestHeader("Content-Type", "application/json");
                    this.http_request.setRequestHeader("If-Modified-Since", "Thu, 1 Jan 1970 00:00:00 GMT");
                    this.http_request.setRequestHeader("Cache-Control", "no-cache");
                    this.http_request.send(this.postdata);
                    if (!this.connectionMode) handler(this.http_request);
                    return true;
                } catch (e) {
                    return true;
                }
            }
            return false;
        };
    };
    WAF.callHandler = function(withError, errorInfo, event, options, userData) {
        var result = null;
        event.userData = userData;
        if (withError) {
            var onError = options.onError;
            event.error = errorInfo;
            if (null != onError) result = onError(event);
        } else {
            var onsuccess = options.onSuccess;
            if (null != onsuccess) result = onsuccess(event);
        }
        return result;
    };
    WAF.getRequestResult = function(request) {
        var response = request.http_request.responseText;
        var result;
        if (null == response) result = {
            __ERROR: [ {
                errCode: -1
            } ]
        }; else try {
            result = JSON.parse(response);
        } catch (e) {
            result = {
                __ERROR: [ e ]
            };
        }
        return result;
    };
    WAF.tools = {};
    WAF.tools.optionMatchers = [ "onSuccess", "onError", "atTheEnd", "sync", "autoExpand", "autoSubExpand", "catalog", "queryString", "skip", "top", "position", "orderby", "orderBy", "params", "queryPlan", "queryPath", "pageSize", "filterSet", "progressInfo", "progressBar", "delay", "delayInfo", "method", "first", "limit", "userData", "addToSet", "atOnce", "refreshOnly", "keepOldCollectionOnError", "isMethodResult", "prefetchedData", "callWithGet", "generateRESTRequestOnly", "forceReload", "doNotAlterElemPos", "overrideStamp", "queryParams", "createEmptyCollection", "forceCollectionRefresh", "refreshCollectionFrom", "removeReferenceOnly", "timeout", "doNotDispatch", "destinationDataSource", "filterAttributes", "subOrderby", "filterQuery", "withinCollection", "keepOrderBy", "retainPositions", "fromInitialQuery", "reselect" ];
    WAF.tools.isOptionParam = function(param) {
        var result = false;
        if (null != param) if ("object" === typeof param) {
            var op = WAF.tools.optionMatchers;
            var len = op.length;
            for (var i = 0; i < len && !result; ++i) {
                var s = op[i];
                if (s in param) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };
    WAF.tools.handleArgs = function(args, startingFrom, handleOptions) {
        var alreadyOptions = false;
        handleOptions = handleOptions || {};
        startingFrom = startingFrom || 0;
        var noUserData = handleOptions.noUserData || false;
        var with3funcs = handleOptions.with3funcs || false;
        var queryParams = handleOptions.queryParams || false;
        var res = {
            options: {},
            userData: null
        };
        var p;
        var nbparam = args.length;
        var nextparam = startingFrom;
        if (nextparam < nbparam) {
            p = args[nextparam];
            if ("function" === typeof p) {
                res.options.onSuccess = p;
                ++nextparam;
                if (nextparam < nbparam) {
                    p = args[nextparam];
                    if ("function" === typeof p) {
                        res.options.onError = p;
                        ++nextparam;
                        if (nextparam < nbparam) {
                            p = args[nextparam];
                            if (with3funcs && "function" === typeof p) {
                                res.options.atTheEnd = p;
                                ++nextparam;
                            }
                        }
                    }
                }
                if (null == res.options.onError) res.options.onError = res.options.onSuccess;
            }
        }
        var params = null;
        if (queryParams) params = [];
        do if (nextparam < nbparam) {
            p = args[nextparam];
            if (!alreadyOptions && WAF.tools.isOptionParam(p)) {
                alreadyOptions = true;
                ++nextparam;
                var oldoptions = res.options;
                res.options = p;
                if (null != oldoptions.onSuccess) res.options.onSuccess = oldoptions.onSuccess;
                if (null != oldoptions.onError) res.options.onError = oldoptions.onError;
                if (null != oldoptions.atTheEnd) res.options.atTheEnd = oldoptions.atTheEnd;
                if (!queryParams) if (nextparam < nbparam && !noUserData) {
                    res.userData = args[nextparam];
                    ++nextparam;
                }
            } else if (queryParams) if ("object" === typeof p && !(p instanceof Date) && !(p instanceof Array)) {
                res.userData = p;
                ++nextparam;
            } else {
                params.push(p);
                ++nextparam;
            }
        } while (queryParams && nextparam < nbparam);
        if (null != res.options.userData && null == res.userData) res.userData = res.options.userData;
        if (queryParams) res.options.params = res.options.params || params;
        res.nextParam = nextparam;
        return res;
    };
    WAF.EntityCache = function(options) {
        options = options || {};
        var cache = this;
        this.maxEntities = options.maxEntities || 300;
        this.timeOut = options.timeOut || 5 * 60 * 1e3;
        this.entitiesByKey = {};
        this.nbEntries = 0;
        this.curStamp = 0;
    };
    WAF.EntityCache.prototype.getNextStamp = function() {
        var cache = this;
        cache.curStamp++;
        return cache.curStamp;
    };
    WAF.EntityCache.prototype.clear = function(nbToClear) {
        var cache = this;
        if (null == nbToClear || nbToClear >= cache.nbEntries) {
            cache.entitiesByKey = {};
            cache.nbEntries = 0;
        } else {
            var all = [];
            var map = cache.entitiesByKey;
            for (var e in map) all.push(map[e]);
            all.sort(function(e1, e2) {
                return e1.timeStamp > e2.timeStamp ? 1 : -1;
            });
            var nbelem = nbToClear;
            if (nbelem > all.length) nbelem = all.length;
            var nbEntries = cache.nbEntries;
            for (var i = 0; i < nbelem; i++) {
                var entry = all[i];
                delete map[entry.key];
                --nbEntries;
            }
            cache.nbEntries = nbEntries;
            delete all;
        }
    };
    WAF.EntityCache.prototype.makeRoomFor = function(nbEntities) {
        var cache = this;
        if (cache.maxEntities < 2 * nbEntities) cache.maxEntities = 2 * nbEntities;
        var remain = cache.maxEntities - cache.nbEntries;
        if (remain < nbEntities) cache.clear(nbEntities - remain);
    };
    WAF.EntityCache.prototype.setEntry = function(key, rawEntity, timeStamp, options) {
        function mergeRawEntity(newRawEntity, oldRawEntity) {
            for (e in oldRawEntity) {
                var newval = newRawEntity[e];
                if (null == newval) newRawEntity[e] = oldRawEntity[e]; else if (null != newval.__deferred) newRawEntity[e] = oldRawEntity[e];
            }
            return newRawEntity;
        }
        var cache = this;
        var map = cache.entitiesByKey;
        var elem = map[key];
        if (null == elem) {
            if (cache.nbEntries >= cache.maxEntities) cache.clear(Math.round(cache.nbEntries / 3));
            cache.nbEntries++;
        } else {
            var oldstamp = -1;
            var newstamp = null;
            if (null != rawEntity) newstamp = rawEntity.__STAMP;
            if (null != elem.rawEntity) oldstamp = elem.rawEntity.__STAMP;
            if (oldstamp === newstamp) rawEntity = mergeRawEntity(rawEntity, elem.rawEntity);
        }
        var newStamp = cache.getNextStamp();
        map[key] = {
            key: key,
            timeStamp: timeStamp,
            rawEntity: rawEntity,
            stamp: newStamp
        };
        return newStamp;
    };
    WAF.EntityCache.prototype.getCacheInfo = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        return elem;
    };
    WAF.EntityCache.prototype.replaceCachedEntity = function(key, rawEntity) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        if (null != elem) {
            elem.timeStamp = new Date();
            elem.rawEntity = rawEntity;
            elem.stamp = cache.getNextStamp();
        }
    };
    WAF.EntityCache.prototype.removeCachedEntity = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        if (null != elem) delete cache.entitiesByKey[key];
    };
    WAF.EntityCache.prototype.setSize = function(nbEntries) {
        if (null == nbEntries || nbEntries < 300) nbEntries = 300;
        this.maxEntities = nbEntries;
    };
    WAF.EntityRefCache = function(options) {
        options = options || {};
        var cache = this;
        this.maxEntities = options.maxEntities || 300;
        this.timeOut = options.timeOut || 5 * 60 * 1e3;
        this.entitiesByKey = {};
        this.nbEntries = 0;
        this.curStamp = 0;
    };
    WAF.EntityRefCache.prototype.clear = function(nbToClear) {
        var cache = this;
        if (null == nbToClear || nbToClear >= cache.nbEntries) {
            cache.entitiesByKey = {};
            cache.nbEntries = 0;
        } else {
            var all = [];
            var map = cache.entitiesByKey;
            for (var e in map) all.push(map[e]);
            all.sort(function(e1, e2) {
                return e1.timeStamp > e2.timeStamp ? 1 : -1;
            });
            var nbelem = nbToClear;
            if (nbelem > all.length) nbelem = all.length;
            var nbEntries = cache.nbEntries;
            for (var i = 0; i < nbelem; i++) {
                var entry = all[i];
                delete map[entry.key];
                --nbEntries;
            }
            cache.nbEntries = nbEntries;
            delete all;
        }
    };
    WAF.EntityRefCache.prototype.makeRoomFor = function(nbEntities) {
        var cache = this;
        if (cache.maxEntities < 2 * nbEntities) cache.maxEntities = 2 * nbEntities;
        var remain = cache.maxEntities - cache.nbEntries;
        if (remain < nbEntities) cache.clear(nbEntities - remain);
    };
    WAF.EntityRefCache.prototype.setEntry = function(entity) {
        var key = entity.getKey();
        if (null != key) {
            var cache = this;
            var map = cache.entitiesByKey;
            var elem = map[key];
            var timeStamp = new Date();
            if (null == elem) {
                if (cache.nbEntries >= cache.maxEntities) cache.clear(Math.round(cache.nbEntries / 3));
                cache.nbEntries++;
                map[key] = {
                    key: key,
                    timeStamp: timeStamp,
                    entity: entity
                };
            } else {
                if (elem.entity !== entity) cache.mergeEntity(elem.entity, entity);
                elem.timeStamp = timeStamp;
            }
        }
    };
    WAF.EntityRefCache.prototype.mergeEntity = function(entity, otherentity) {
        entity._private.stamp = otherentity._private.stamp;
        entity._private.touched = false;
        var values = entity._private.values;
        var othervalues = otherentity._private.values;
        var attsByName = entity._private.dataClass._private.attributesByName;
        for (var e in attsByName) {
            var attval = othervalues[e] || null;
            if (null == attval) {
                delete values[e];
                delete entity[e];
            } else {
                values[e] = attval;
                entity[e] = attval;
            }
        }
    };
    WAF.EntityRefCache.prototype.getCacheInfo = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        return elem;
    };
    WAF.EntityRefCache.prototype.removeCachedEntity = function(key) {
        var cache = this;
        var elem = cache.entitiesByKey[key];
        if (null != elem) delete cache.entitiesByKey[key];
    };
    WAF.EntityRefCache.prototype.setSize = function(nbEntries) {
        if (null == nbEntries || nbEntries < 300) nbEntries = 300;
        this.maxEntities = nbEntries;
    };
    WAF.DataStore = function(options, userData) {
        options = options || {};
        userData = userData;
        var dataStore = this;
        this._private = {
            owner: this,
            dataClasses: {},
            dataClassesByCollectionName: {},
            ready: false,
            cacheRef: options.cacheRef || false,
            getCatalog: WAF.DataStore.getCatalog
        };
        dataStore._private.getCatalog(options, userData);
    };
    WAF.DataStore.prototype.getDataClass = function(name) {
        var priv = this._private;
        var dataClass = priv.dataClasses[name];
        if (null == dataClass) dataClass = priv.dataClassesByCollectionName[name];
        return dataClass;
    };
    WAF.DataStore.prototype.getDataClasses = function() {
        var priv = this._private;
        return priv.dataClasses;
    };
    WAF.DataStore.prototype.mustCacheRef = function() {
        return this._private.cacheRef;
    };
    WAF.DataStore.prototype.addToCatalog = function(dataClassesList, options, userData) {
        userData = userData || null;
        options = options || {};
        var priv = this._private;
        options.catalog = dataClassesList;
        options.mergeCatalog = true;
        priv.getCatalog(options, userData);
    };
    WAF.DataStore.resolveRelatedAttribute = function() {
        if (!this.resolved) {
            var dataStore = this.owner.getDataStore();
            this.relatedClass = dataStore.getDataClass(this.type);
            if (null != this.relatedClass) this.resolved = true;
        }
    };
    WAF.DataStore.getRelatedClassAttribute = function() {
        this.resolve();
        return this.relatedClass;
    };
    WAF.DataStore.handleFuncResult = function(request, methodref, dataClass) {
        var fullResult = WAF.getRequestResult(request);
        if (null == fullResult.__ERROR) {
            if (null != fullResult.__entityModel) dataClass = dataClass.getDataStore().getDataClass(fullResult.__entityModel);
            if (null != fullResult.__KEY || null != fullResult.__STAMP) {
                var entity = new WAF.Entity(dataClass, fullResult, {
                    getRefFromCache: true
                });
                fullResult = {
                    result: entity
                };
            } else if (null != fullResult.__ENTITIES) {
                var entityCollection = new WAF.EntityCollection(dataClass, null, {
                    prefetchedData: fullResult,
                    isMethodResult: true
                });
                fullResult = {
                    result: entityCollection
                };
            }
        }
        return fullResult;
    };
    WAF.DataStore.funcCaller = function(methodref, from, params, options) {
        var result = null;
        options = options || {};
        var oktogo = true;
        var sync = options.sync || false;
        var callWithGet = methodref.callWithGet || options.callWithGet || false;
        var generateRESTRequestOnly = options.generateRESTRequestOnly || false;
        var request = new WAF.core.restConnect.restRequest(!sync);
        if (callWithGet) request.httpMethod = WAF.core.restConnect.httpMethods._get; else request.httpMethod = WAF.core.restConnect.httpMethods._post;
        var entity = null;
        var dataClass = null;
        var entityCollection = null;
        var jsonargs = JSON.stringify(params);
        if (callWithGet) request.params = params; else request.postdata = jsonargs;
        if ("entity" == methodref.applyTo) {
            entity = from;
            dataClass = entity.getDataClass();
            request.attributesRequested = [ methodref.name ];
            request.resource = dataClass.getNameForRest() + "(";
            var key = entity.getKey();
            if (null != key) request.resource += key;
            request.resource += ")";
        } else if ("entityCollection" == methodref.applyTo) {
            entityCollection = from;
            dataClass = entityCollection.getDataClass();
            if (null != entityCollection._private.dataURI) request.dataURI = entityCollection._private.dataURI + "/" + methodref.name; else {
                request.attributesRequested = [ methodref.name ];
                request.resource = dataClass.getNameForRest();
                request.filter = options.queryString;
            }
            request.savedQueryString = entityCollection._private.savedQuery;
            request.savedOrderby = entityCollection._private.savedOrderby;
            entityCollection._private.updateOptions(options);
        } else if ("general" == methodref.applyTo) {
            request.resource = methodref.nameSpace;
            request.attributesRequested = [ methodref.name ];
        } else {
            dataClass = from;
            request.attributesRequested = [ methodref.name ];
            request.resource = dataClass.getNameForRest();
        }
        var pageSize = options.pageSize || 40;
        request.top = pageSize;
        request.method = "entityset";
        request.timeout = 300;
        request.addToSet = options.addToSet;
        if (null != options.autoExpand) request.autoExpand = options.autoExpand;
        if (null != options.filterAttributes) request.filterAttributes = options.filterAttributes;
        if (!sync) request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var fullResult = WAF.DataStore.handleFuncResult(request, methodref, dataClass);
            var event = {
                result: fullResult.result
            };
            var err = fullResult.__ERROR;
            var userData = options.userData || null;
            event.XHR = request.http_request;
            WAF.callHandler(null != err, err, event, options, userData);
        };
        if (generateRESTRequestOnly) result = request.go({
            generateRESTRequestOnly: true
        }); else {
            request.go();
            if (sync) {
                var successCallback, failCallback;
                successCallback = function() {};
                failCallback = function() {};
                if (params.length > 0) {
                    if (params[0] && "function" == typeof params[0]) successCallback = params[0];
                    if (params[1] && "function" == typeof params[1]) failCallback = params[1];
                }
                if (4 != request.http_request.readyState) throw {
                    error: 401
                }; else {
                    var fullResult = WAF.DataStore.handleFuncResult(request, methodref, dataClass);
                    if (null != fullResult.__ERROR) {
                        failCallback(fullResult);
                        throw fullResult.__ERROR;
                    } else {
                        result = fullResult.result;
                        successCallback(result);
                    }
                }
            }
        }
        return result;
    };
    WAF.DataStore.callMethod = function(options) {
        var result = null;
        var em = this;
        var methodRef = em._private.dataClassMethodRefs[options.method];
        if (null != methodRef) {
            var myargs = [];
            if (null != options.arguments) myargs = options.arguments; else for (var i = 1, nb = arguments.length; i < nb; i++) myargs.push(arguments[i]);
            result = WAF.DataStore.funcCaller(methodRef, em, myargs, options);
        }
        return result;
    };
    WAF.DataStore.makeFuncCaller = function(methodRef) {
        var methodref = methodRef;
        var func = function() {
            var options;
            var alreadyParsedOptions = false;
            var myargs = [];
            for (var i = 0, nb = arguments.length; i < nb; i++) {
                var p = arguments[i];
                if (!alreadyParsedOptions && WAF.tools.isOptionParam(p)) {
                    options = p;
                    alreadyParsedOptions = true;
                } else myargs.push(p);
            }
            var xoptions = options || {};
            if (void 0 === xoptions.onSuccess && void 0 === xoptions.onError && void 0 === xoptions.generateRESTRequestOnly) xoptions.sync = true;
            return WAF.DataStore.funcCaller(methodref, this, myargs, xoptions);
        };
        return func;
    };
    WAF.DataStore.getCatalog = function(options, userData) {
        var priv = this;
        var dataStore = this.owner;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var merge = options.mergeCatalog || false;
        var alreadyDone = false;
        var catResource = "$all";
        priv.cacheRef = priv.cacheRef || options.cacheRef || false;
        var catname = "";
        var catalogPrefix = null;
        if (null != options.catalogName && "string" === typeof options.catalogName) {
            catname = options.catalogName + "/";
            catalogPrefix = options.catalogName;
        }
        if (null != options.catalog) {
            if ("string" === typeof options.catalog) catResource = options.catalog; else catResource = options.catalog.join(",");
            if (merge) {
                classList = catResource.split(",");
                newlist = [];
                classList.forEach(function(classname) {
                    if ("" != classname && null == dataStore[classname]) newlist.push(classname);
                });
                if (0 == newlist.length) alreadyDone = true;
            }
        }
        if (alreadyDone) {
            var event = {
                dataStore: dataStore,
                result: dataStore
            };
            WAF.callHandler(false, null, event, options, userData);
        } else {
            catResource = "$catalog/" + catname + catResource;
            var request = new WAF.core.restConnect.restRequest(true);
            request.resource = catResource;
            request.handler = function() {
                if (4 != request.http_request.readyState) return;
                var error = false;
                var entitiesList = null;
                var err = null;
                try {
                    var result = WAF.getRequestResult(request);
                    if (result && result.dataClasses) entitiesList = result.dataClasses; else if (result && result.className) entitiesList = [ result ];
                    if (null == entitiesList) entitiesList = [];
                    if (null != result.__ERROR) {
                        error = true;
                        err = result.__ERROR;
                    }
                } catch (e) {
                    entitiesList = [];
                    error = true;
                    err = e;
                }
                for (var i = 0, nb = entitiesList.length; i < nb; i++) {
                    var dataClassInfo = entitiesList[i];
                    var emName = dataClassInfo.name;
                    if (null == dataStore[emName]) {
                        var collectionName = dataClassInfo.collectionName;
                        var dataClass = new WAF.DataClass(dataClassInfo, dataStore, catalogPrefix);
                        priv.dataClasses[emName] = dataClass;
                        if (null != collectionName) priv.dataClassesByCollectionName[collectionName] = dataClass;
                        dataStore[emName] = dataClass;
                    }
                }
                priv.ready = true;
                var event = {
                    dataStore: dataStore,
                    result: dataStore
                };
                event.XHR = request.http_request;
                WAF.callHandler(error, err, event, options, userData);
            };
            var errorFlag = request.go();
        }
    };
    WAF.DataClass = function(dataClassInfo, dataStore, catalogPrefix) {
        var dataClass = this, primaryKey = "";
        if (dataClassInfo.key) primaryKey = dataClassInfo.key[0].name;
        dataClass._private = {
            primaryKey: primaryKey,
            className: dataClassInfo.name,
            collectionName: dataClassInfo.collectionName,
            attributesByName: {},
            entityMethods: {},
            entityCollectionMethods: {},
            entityMethodRefs: {},
            entityCollectionMethodRefs: {},
            dataClassMethodRefs: {},
            owner: dataClass,
            dataStore: dataStore,
            catalogPrefix: catalogPrefix,
            cache: new WAF.EntityCache(),
            refCache: new WAF.EntityRefCache(),
            defaultTopSize: dataClassInfo.defaultTopSize,
            getEntityByURIOrKey: WAF.DataClass.getEntityByURIOrKey
        };
        var priv = dataClass._private;
        var attsByName = priv.attributesByName;
        var dataClassMethodRefs = priv.dataClassMethodRefs;
        var entityCollectionMethodRefs = priv.entityCollectionMethodRefs;
        var entityMethodRefs = priv.entityMethodRefs;
        var entityCollectionMethods = priv.entityCollectionMethods;
        var entityMethods = priv.entityMethods;
        var attributes = dataClassInfo.attributes;
        var methods = dataClassInfo.methods;
        priv.methods = methods;
        if (null != attributes) for (var j = 0, nbatt = attributes.length; j < nbatt; j++) {
            var att = attributes[j];
            att.owner = dataClass;
            attsByName[att.name] = att;
            if ("storage" == att.kind || "calculated" == att.kind || "alias" == att.kind || "composition" == att.kind) {
                att.simple = true;
                att.related = false;
                if ("image" == att.type || "blob" == att.type) att.simple = false;
            } else {
                att.simple = false;
                att.related = true;
                att.resolved = false;
                att.relatedOne = "relatedEntity" == att.kind;
                att.resolve = WAF.DataStore.resolveRelatedAttribute;
                att.getRelatedClass = WAF.DataStore.getRelatedClassAttribute;
                att.relatedClass = null;
            }
            dataClass[att.name] = att;
        }
        priv.attributes = attributes;
        var methlist = methods;
        if (null != methlist) for (var j = 0, nbmethod = methlist.length; j < nbmethod; j++) {
            var methodRef = methlist[j];
            if ("entity" == methodRef.applyTo) {
                entityMethodRefs[methodRef.name] = methodRef;
                entityMethods[methodRef.name] = WAF.DataStore.makeFuncCaller(methodRef);
            } else if ("entityCollection" == methodRef.applyTo) {
                entityCollectionMethodRefs[methodRef.name] = methodRef;
                entityCollectionMethods[methodRef.name] = WAF.DataStore.makeFuncCaller(methodRef);
            } else {
                dataClassMethodRefs[methodRef.name] = methodRef;
                dataClass[methodRef.name] = WAF.DataStore.makeFuncCaller(methodRef);
            }
        }
        return this;
    };
    WAF.DataClass.getEntityByURIOrKey = function(key, dataURI, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 2);
        userData = resOp.userData;
        options = resOp.options;
        var priv = this;
        var dataClass = priv.owner;
        var request = new WAF.core.restConnect.restRequest(true);
        if (null != dataURI) request.fullURL = dataURI; else request.resource = dataClass.getNameForRest() + "(" + key + ")";
        request.autoExpand = options.autoExpand;
        request.autoSubExpand = options.autoSubExpand;
        request.filterAttributes = options.filterAttributes;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            }
            var entity = null;
            if (!error) {
                var cacheRef = dataClass.mustCacheRef();
                entity = new WAF.Entity(dataClass, result, {
                    getRefFromCache: cacheRef
                });
                if (!cacheRef) {
                    var key = entity.getKey();
                    var cache = dataClass.getCache();
                    var cacheInfo = cache.getCacheInfo(key);
                    if (null == cacheInfo) {
                        var timeStamp = new Date();
                        cache.setEntry(key, result, timeStamp);
                    } else cache.replaceCachedEntity(key, result);
                }
            }
            var event = {
                entity: entity,
                result: entity
            };
            event.XHR = request.http_request;
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.DataClass.mustCacheRef = function() {
        return this._private.dataStore.mustCacheRef();
    };
    WAF.DataClass.getName = function() {
        return this._private.className;
    };
    WAF.DataClass.getNameForRest = function() {
        var res = this._private.className;
        if (null != this._private.catalogPrefix) res = this._private.catalogPrefix + "/" + res;
        return res;
    };
    WAF.DataClass.getCollectionName = function() {
        return this._private.collectionName;
    };
    WAF.DataClass.getDefaultTopSize = function() {
        return this._private.defaultTopSize;
    };
    WAF.DataClass.getDataStore = function() {
        return this._private.dataStore;
    };
    WAF.DataClass.getCache = function() {
        return this._private.cache;
    };
    WAF.DataClass.getRefCache = function() {
        return this._private.refCache;
    };
    WAF.DataClass.setCacheSize = function(nbEntries) {
        var cache = this._private.cacheRef ? this._private.refCache : this._private.cache;
        cache.setSize(nbEntries);
    };
    WAF.DataClass.getCacheSize = function() {
        var cache = this._private.cacheRef ? this._private.refCache : this._private.cache;
        return cache.maxEntities;
    };
    WAF.DataClass.clearCache = function() {
        var cache = this._private.cacheRef ? this._private.refCache : this._private.cache;
        cache.clear();
    };
    WAF.DataClass.getAttributeByName = function(attName) {
        var dataClass = this;
        return dataClass._private.attributesByName[attName];
    };
    WAF.DataClass.getAttributes = function() {
        var dataClass = this;
        return dataClass._private.attributes;
    };
    WAF.DataClass.getMethodList = function() {
        var dataClass = this;
        return dataClass._private.methods;
    };
    WAF.DataClass.newEntity = function() {
        var entity = new WAF.Entity(this);
        return entity;
    };
    WAF.DataClass.getEntity = function(key, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        if (dataClass.mustCacheRef()) {
            var cache = dataClass.getRefCache();
            var cacheInfo;
            if (options.forceReload) cacheInfo = null; else cacheInfo = cache.getCacheInfo(key);
            if (null == cacheInfo) dataClass._private.getEntityByURIOrKey(key, null, options, userData); else {
                var entity = cacheInfo.entity;
                var event = {
                    entity: entity,
                    result: entity
                };
                var result = WAF.callHandler(false, null, event, options, userData);
                if ("boolean" == typeof result) if (!result) if (null != options) options.mustStopLoop = true;
            }
        } else {
            var cache = dataClass.getCache();
            var cacheInfo;
            if (options.forceReload) cacheInfo = null; else cacheInfo = cache.getCacheInfo(key);
            if (null == cacheInfo || null == cacheInfo.rawEntity) dataClass._private.getEntityByURIOrKey(key, null, options, userData); else {
                var entity = new WAF.Entity(dataClass, cacheInfo.rawEntity);
                var event = {
                    entity: entity,
                    result: entity
                };
                var result = WAF.callHandler(false, null, event, options, userData);
                if ("boolean" == typeof result) if (!result) if (null != options) options.mustStopLoop = true;
            }
        }
    };
    WAF.DataClass.newCollection = function(collectionReference, options, userData) {
        if (null == collectionReference) {
            var collection = new WAF.EntityCollection(this, null, {
                createEmptyCollection: true
            });
            return collection;
        } else {
            var resOp = WAF.tools.handleArgs(arguments, 1);
            userData = resOp.userData;
            options = resOp.options;
            options.dataURI = collectionReference.dataURI;
            options.pageSize = options.pageSize || collectionReference.pageSize;
            options.autoExpand = options.autoExpand || collectionReference.autoExpand;
            options.filterAttributes = options.filterAttributes || collectionReference.filterAttributes;
            options.savedQuery = collectionReference.savedQuery || null;
            options.savedOrderby = collectionReference.savedOrderby || null;
            var collection = new WAF.EntityCollection(this, null, options, userData);
            return collection;
        }
    };
    WAF.DataClass.getEntityByURI = function(dataURI, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        dataClass._private.getEntityByURIOrKey(null, dataURI, options, userData);
    };
    WAF.DataClass.distinctValues = function(attributeName, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var queryString = options.queryString;
        var skip = options.skip;
        var top = options.top;
        var dataClass = this;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClass.getNameForRest();
        request.filter = queryString;
        request.skip = skip;
        request.top = top;
        request.options = {
            objectRef: this,
            first: skip,
            top: top
        };
        if (null != attributeName) request.attributesRequested = [ attributeName ];
        request.distinct = true;
        request.addToSet = options.addToSet;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var withError = false;
            var err = null;
            if (null != rawResult.__ERROR) {
                err = rawResult.__ERROR;
                withError = true;
                for (var ierr = 0; ierr < rawResult.__ERROR.length; ierr++) {
                    var rawerr = rawResult.__ERROR[ierr];
                    if (null == rawerr.options) rawerr.options = {};
                    rawerr.options.position = first;
                }
            }
            var event = {
                result: rawResult,
                distinctValues: rawResult,
                XHR: request.http_request
            };
            WAF.callHandler(withError, err, event, options, userData);
        };
        request.go();
    };
    WAF.DataClass.query = function(queryString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1, {
            queryParams: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        var entityCollection = new WAF.EntityCollection(dataClass, queryString, options, userData);
        return entityCollection;
    };
    WAF.DataClass.allEntities = function(options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        return this.query("", options, userData);
    };
    WAF.DataClass.find = function(queryString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1, {
            queryParams: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        var priv = this._private;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClass.getNameForRest();
        request.autoExpand = options.autoExpand;
        request.filterAttributes = options.filterAttributes;
        request.filter = queryString;
        request.top = 1;
        request.orderby = options.orderby;
        request.params = options.params;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            }
            var entity = null;
            if (!error && null != result.__ENTITIES && result.__ENTITIES.length > 0) entity = new WAF.Entity(dataClass, result.__ENTITIES[0], {
                getRefFromCache: true
            });
            var event = {
                entity: entity,
                result: entity,
                XHR: request.http_request
            };
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.DataClass.toArray = function(attributeList, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = this;
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = this.getNameForRest();
        request.top = options.top || null;
        request.skip = options.skip || null;
        request.addToSet = options.addToSet;
        request.retainPositions = options.retainPositions || null;
        request.progressInfo = options.progressInfo;
        request.orderby = options.orderby;
        request.autoExpand = attributeList;
        request.asArray = true;
        if (options.filterQuery) {
            request.filter = options.filterQuery;
            request.params = options.params;
        }
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                dataClass: dataClass,
                result: rawResult,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollectionPage = function(start, length) {
        var page = this;
        this.start = start;
        this.length = length;
        this.entityKeys = [];
    };
    WAF.EntityCollection = function(dataClass, queryString, options, userData) {
        if ("''" == queryString || "" == queryString) queryString = null;
        var resOp = WAF.tools.handleArgs(arguments, 2);
        userData = resOp.userData;
        options = resOp.options;
        var dejaSet = options.filterSet;
        var savedQuery;
        if (null != dejaSet) {
            savedQuery = dejaSet._private.savedQuery;
            if (null != savedQuery) {
                if (null != queryString) savedQuery = "(" + savedQuery + ") and " + queryString;
            } else saveQuery = queryString;
        } else savedQuery = queryString;
        if (null == savedQuery) savedQuery = options.savedQuery || null;
        if (null == options.orderby && null != options.orderBy) options.orderby = options.orderBy;
        var savedOrderby = options.orderby || null;
        if (null == savedOrderby) savedOrderby = options.savedOrderby || null;
        var pageSize = options.pageSize || 40;
        var entityCollection = this;
        this._private = {
            ready: false,
            owner: this,
            queryString: queryString,
            savedQuery: savedQuery,
            orderby: savedOrderby,
            savedOrderby: savedOrderby,
            dataURI: options.dataURI,
            pageSize: pageSize,
            withQueryPlan: options.queryPlan,
            withQueryPath: options.queryPath,
            progressInfo: options.progressInfo,
            params: options.params,
            dataClass: dataClass,
            methodRefs: dataClass._private.entityCollectionMethodRefs,
            methods: dataClass._private.entityCollectionMethods,
            autoExpand: options.autoExpand,
            autoSubExpand: options.autoSubExpand,
            filterAttributes: options.filterAttributes,
            isMethodResult: options.isMethodResult,
            isARelatedEntityCollection: options.isARelatedEntityCollection,
            loadedElemsLength: 0,
            addedElems: [],
            curPendingStamp: 0,
            pendingRequests: {},
            pages: [],
            clearCache: WAF.EntityCollection.clearCache,
            insertPage: WAF.EntityCollection.insertPage,
            findPage: WAF.EntityCollection.findPage,
            invalidPage: WAF.EntityCollection.invalidPage,
            getKeyByPos: WAF.EntityCollection.getKeyByPos,
            manageData: WAF.EntityCollection.manageData,
            fetchData: WAF.EntityCollection.fetchData,
            addPendingRequest: WAF.EntityCollection.addPendingRequest,
            clearPendingRequest: WAF.EntityCollection.clearPendingRequest,
            clearAllPendingRequest: WAF.EntityCollection.clearAllPendingRequest,
            isPagePending: WAF.EntityCollection.isPagePending,
            gotEntity: WAF.EntityCollection.gotEntity,
            updateOptions: WAF.EntityCollection.updateOptions
        };
        var priv = this._private;
        var methods = priv.methods;
        for (var e in methods) entityCollection[e] = methods[e];
        this.length = 0;
        options.init = true;
        if (options.createEmptyCollection) {
            priv.ready = true;
            queryString = "*";
        } else if (null != options.dataURI && "*" == options.dataURI) priv.ready = true; else if (null != options.prefetchedData) entityCollection._private.manageData(options.prefetchedData, true); else {
            if (null == queryString && null == priv.savedQuery) priv.savedQuery = "$all";
            entityCollection._private.fetchData(0, pageSize, options, userData);
        }
        return entityCollection;
    };
    WAF.EntityCollection.clearCache = function() {
        var priv = this;
        priv.pages = [];
    };
    WAF.EntityCollection.insertPage = function(page) {
        var priv = this;
        var pages = priv.pages;
        var nbpages = pages.length;
        if (0 == nbpages) pages.push(page); else {
            var posToInsert = -1;
            for (var i = 0; i < nbpages; i++) {
                var xpage = pages[i];
                if (xpage.start > page.start) {
                    posToInsert = i;
                    break;
                }
            }
            if (posToInsert == -1) pages.push(page); else pages.splice(posToInsert, 0, page);
        }
    };
    WAF.EntityCollection.findPage = function(pos) {
        var priv = this;
        var pages = priv.pages;
        var nbpages = pages.length;
        var low = 0;
        var high = nbpages;
        while (high > low) {
            var middle = Math.floor((high - low) / 2) + low;
            var page = pages[middle];
            if (page.start <= pos && page.start + page.length > pos) return middle; else if (pos < page.start) high = middle; else low = middle + 1;
        }
        return -1;
    };
    WAF.EntityCollection.invalidPage = function(pos) {
        var priv = this;
        var pagePos = priv.findPage(pos);
        if (pagePos != -1) priv.pages.splice(pagePos, 1);
    };
    WAF.EntityCollection.getKeyByPos = function(pos) {
        var result = null;
        var priv = this;
        var pagePos = priv.findPage(pos);
        if (pagePos != -1) {
            var page = priv.pages[pagePos];
            var keyElem = page.entityKeys[pos - page.start];
            result = keyElem.key;
        }
        return result;
    };
    WAF.EntityCollection.addPendingRequest = function(start, length) {
        var priv = this;
        priv.curPendingStamp++;
        priv.pendingRequests[priv.curPendingStamp] = {
            start: start,
            length: length
        };
        return priv.curPendingStamp;
    };
    WAF.EntityCollection.clearPendingRequest = function(pendingStamp) {
        var priv = this;
        delete priv.pendingRequests[pendingStamp];
    };
    WAF.EntityCollection.clearAllPendingRequest = function() {
        var priv = this;
        for (var e in priv.pendingRequests) priv.pendingRequests[e];
    };
    WAF.EntityCollection.isPagePending = function(pos) {
        var priv = this;
        for (var e in priv.pendingRequests) {
            var pendingRequest = priv.pendingRequests[e];
            if (pendingRequest.start <= pos && pendingRequest.start + pendingRequest.length > pos) return true;
        }
        return false;
    };
    WAF.EntityCollection.manageData = function(rawResult, init) {
        var priv = this;
        var entityCollection = this.owner;
        var dataClass = entityCollection.getDataClass();
        var cache;
        init = init || false;
        if (init) {
            entityCollection.length = rawResult.__COUNT;
            priv.ready = true;
            priv.loadedElemsLength = entityCollection.length;
            priv.dataURI = rawResult.__ENTITYSET;
            if (null != priv.autoSubExpand) {
                priv.autoExpand = priv.autoSubExpand;
                priv.autoSubExpand = null;
            }
        }
        var nbEnts = rawResult.__SENT;
        var first = rawResult.__FIRST;
        var arr = rawResult.__ENTITIES;
        var timeStamp = new Date();
        var page = new WAF.EntityCollectionPage(first, nbEnts);
        var cacheref = dataClass.mustCacheRef();
        if (cacheref) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
        cache.makeRoomFor(nbEnts);
        for (var i = 0; i < nbEnts; i++) {
            var rawEntity = arr[i];
            var xkey;
            if (null == rawEntity) {
                if (!cacheref) cache.setEntry("", {
                    __STAMP: 0
                }, timeStamp);
                xkey = "";
            } else {
                var stamp = -1;
                xkey = rawEntity.__KEY;
                if (null == xkey) xkey = "";
                if (cacheref) var entity = new WAF.Entity(dataClass, rawEntity, {
                    getRefFromCache: true
                }); else stamp = cache.setEntry(xkey, rawEntity, timeStamp);
            }
            page.entityKeys.push({
                key: rawEntity.__KEY,
                stamp: stamp
            });
        }
        priv.insertPage(page);
    };
    WAF.EntityCollection.fetchData = function(skip, top, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 2);
        userData = resOp.userData;
        options = resOp.options;
        var dejaSet = options.filterSet;
        var init = options.init || false;
        var priv = this;
        var entityCollection = this.owner;
        var dataClass = entityCollection.getDataClass();
        var cache = dataClass.getCache();
        var pendingStamp = priv.addPendingRequest(skip, top);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getNameForRest();
        if (null != dejaSet) if (null != dejaSet._private.dataURI) {
            request.dataURI = dejaSet._private.dataURI;
            request.filter = priv.queryString;
        } else request.filter = priv.savedQuery; else request.filter = priv.queryString;
        request.top = top;
        request.skip = skip;
        request.attributesRequested = null;
        request.attributesExpanded = null;
        request.autoExpand = priv.autoExpand;
        request.autoSubExpand = priv.autoSubExpand;
        request.filterAttributes = priv.filterAttributes;
        request.params = priv.params;
        if (priv.mustRefreshCollectionOnNextFetch) {
            request.refreshOnly = true;
            priv.mustRefreshCollectionOnNextFetch = false;
        }
        if (options.fromSelection) request.fromSelection = options.fromSelection;
        if (init) {
            request.removeAtPos = options.removeAtPos;
            request.removeReferenceOnly = options.removeReferenceOnly;
            request.addToSet = options.addToSet;
            var sel = request.fromSelection;
            if (null != sel) request.fromSelection = sel.prepareToSend();
        }
        request.queryPlan = priv.withQueryPlan;
        request.progressInfo = priv.progressInfo;
        if (priv.isARelatedEntityCollection) request.method = "subentityset"; else request.method = "entityset";
        request.timeout = options.timeout || 300;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = request.dataURI || priv.dataURI;
        if (request.dataURI && null == dejaSet) request.filter = null;
        request.orderby = options.orderby;
        request.subOrderby = options.subOrderby;
        request.keepSelection = options.keepSelection;
        request.reselect = options.reselect;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            priv.clearPendingRequest(pendingStamp);
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                result: entityCollection,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            if (!withError) {
                if (null != rawResult.__transformedSelection) event.transformedSelection = rawResult.__transformedSelection;
                priv.manageData(rawResult, init);
            }
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.updateOptions = function(options) {
        var priv = this;
        if (priv.addedElems.length > 0) {
            var addedKeys = [];
            for (var i = 0, nbelem = priv.addedElems.length; i < nbelem; i++) {
                var e = priv.addedElems[i];
                var key = null;
                if (null != e && e.getKey) key = e.getKey();
                if (null != key) addedKeys.push(key);
            }
            if (addedKeys.length > 0) options.addToSet = addedKeys;
        }
    };
    WAF.EntityCollection.getDataClass = function() {
        var entityCollection = this;
        return entityCollection._private.dataClass;
    };
    WAF.EntityCollection.getReference = function() {
        var result = null;
        var entityCollection = this;
        var priv = entityCollection._private;
        if (null != priv.dataURI) {
            result = {
                dataURI: priv.dataURI
            };
            if (null != priv.savedQuery) result.savedQuery = priv.savedQuery;
            if (null != priv.savedOrderby) result.savedOrderby = priv.savedOrderby;
            if (null != priv.pageSize) result.pageSize = priv.pageSize;
            if (null != priv.autoExpand) result.autoExpand = priv.autoExpand;
        }
        return result;
    };
    WAF.EntityCollection.query = function(queryString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1, {
            queryParams: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        options.filterSet = entityCollection;
        var dataClass = entityCollection.getDataClass();
        options.pageSize = options.pageSize || entityCollection._private.pageSize;
        options.autoExpand = options.autoExpand || entityCollection._private.autoExpand;
        options.filterAttributes = options.filterAttributes || entityCollection._private.filterAttributes;
        entityCollection._private.updateOptions(options);
        var subEntityCollection = new WAF.EntityCollection(dataClass, queryString, options, userData);
        return subEntityCollection;
    };
    WAF.EntityCollection.orderBy = function(orderByString, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        if (0 == this.length) {
            var event = {
                entityCollection: entityCollection,
                result: entityCollection
            };
            WAF.callHandler(false, null, event, options, userData);
            return entityCollection;
        } else {
            options.orderby = orderByString;
            var priv = entityCollection._private;
            options.dataURI = priv.dataURI;
            var dataClass = entityCollection.getDataClass();
            options.pageSize = options.pageSize || priv.pageSize;
            options.autoExpand = options.autoExpand || priv.autoExpand;
            options.filterAttributes = options.filterAttributes || priv.filterAttributes;
            priv.updateOptions(options);
            options.savedQuery = priv.savedQuery || null;
            var subEntityCollection = new WAF.EntityCollection(dataClass, null, options, userData);
            return subEntityCollection;
        }
    };
    WAF.EntityCollection.getEntities = function(pos, howMany, options, userData) {
        var entityCollection = this;
        var priv = entityCollection._private;
        if (priv.ready) {
            if (pos + howMany > entityCollection.length) howMany = entityCollection.length - pos;
            var resOp = WAF.tools.handleArgs(arguments, 2);
            userData = resOp.userData;
            options = resOp.options;
            var lenFromServer = priv.loadedElemsLength;
            var lenLocal = priv.addedElems.length;
            var dataClass = entityCollection.getDataClass();
            priv.updateOptions(options);
            var result = [];
            var newevent = {
                entityCollection: entityCollection,
                result: entityCollection,
                position: pos,
                howMany: howMany,
                entities: result
            };
            var errorOccured = null;
            entityCollection.forEach({
                first: pos,
                limit: pos + howMany,
                onSuccess: function(ev) {
                    result.push(ev.entity);
                },
                onError: function(ev) {
                    errorOccured = ev.error;
                },
                atTheEnd: function(ev) {
                    if (null != errorOccured) WAF.callHandler(true, errorOccured, newevent, options, userData); else WAF.callHandler(false, null, newevent, options, userData);
                }
            });
        } else setTimeout(function() {
            entityCollection.getEntities(pos, howMany, options, userData);
        }, 100);
    };
    WAF.EntityCollection.getEntity = function(pos, options, userData, doNotFetch) {
        var executed = false;
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var forceCollectionRefresh = null != options && (options.forceCollectionRefresh || false);
        if (resOp.nextParam < arguments.length) doNotFetch = arguments[resOp.nextParam] || false; else doNotFetch = false;
        var entityCollection = this;
        var priv = entityCollection._private;
        var lenToCheck = priv.loadedElemsLength;
        if (forceCollectionRefresh) {
            priv.clearAllPendingRequest();
            priv.clearCache();
            priv.mustRefreshCollectionOnNextFetch = true;
            lenToCheck = entityCollection.length;
        }
        var dataClass = entityCollection.getDataClass();
        if (pos >= lenToCheck) {
            executed = true;
            var newevent = {
                entityCollection: entityCollection,
                result: entityCollection,
                position: pos
            };
            var subpos = pos - priv.loadedElemsLength;
            if (subpos < priv.addedElems.length) {
                newevent.entity = priv.addedElems[subpos];
                WAF.callHandler(false, null, newevent, options, userData);
            } else if (forceCollectionRefresh) WAF.callHandler(false, null, newevent, options, userData); else WAF.callHandler(true, [ {
                error: 501,
                message: "wrong position in entityCollection"
            } ], newevent, options, userData);
        } else {
            var okfetch = false;
            var key = priv.getKeyByPos(pos);
            if (null == key && !doNotFetch) if (priv.isPagePending(pos)) setTimeout(function() {
                entityCollection.getEntity(pos, options, userData);
            }, 100); else okfetch = true;
            if (null != key) {
                var cacheRef = dataClass.mustCacheRef();
                var cache;
                if (cacheRef) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
                var cacheInfo = cache.getCacheInfo(key);
                if (null != cacheInfo) {
                    executed = true;
                    priv.gotEntity(cacheInfo, options, userData, pos);
                } else {
                    okfetch = true;
                    key = null;
                    priv.invalidPage(pos);
                }
            }
            if (doNotFetch) okfetch = false;
            if (null == key && okfetch) {
                var delay, delayInfo;
                if (null != options) {
                    delay = options.delay;
                    delayInfo = options.delayInfo;
                } else {
                    delay = null;
                    delayInfo = null;
                }
                if (null != delay && 0 != delay && null != delayInfo) {
                    var delayReq = delayInfo.findMatchingPendingRequest(pos);
                    if (null == delayReq) {
                        var posbefore = pos - 20;
                        if (posbefore < 0) posbefore = 0;
                        delayReq = delayInfo.addPendingRequest(0, posbefore, pos + priv.pageSize - 1);
                        delayReq.addFetchRequest(pos, options, userData);
                        var requestid = setTimeout(function() {
                            if (delayReq.matchRange(delayInfo.top, delayInfo.bottom)) {
                                var newOptions = {};
                                if (forceCollectionRefresh) priv.updateOptions(newOptions);
                                priv.fetchData(delayReq.top, delayReq.bottom - delayReq.top + 1, {
                                    onSuccess: function(event) {
                                        if (forceCollectionRefresh) priv.addedElems = [];
                                        delayReq.pendingFetch.forEach(function(fetchItem) {
                                            if (fetchItem.pos >= delayInfo.top && fetchItem.pos <= delayInfo.bottom) {
                                                var key = priv.getKeyByPos(fetchItem.pos);
                                                var cacheRef = dataClass.mustCacheRef();
                                                var cache;
                                                if (cacheRef) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
                                                var cacheInfo = cache.getCacheInfo(key);
                                                if (null != cacheInfo) priv.gotEntity(cacheInfo, fetchItem.options, fetchItem.userData, fetchItem.pos); else priv.gotEntity(null, fetchItem.options, fetchItem.userData);
                                            }
                                        });
                                        delayInfo.removePendingRequest(delayReq);
                                    },
                                    onError: function(event) {
                                        delayReq.pendingFetch.forEach(function(fetchItem) {
                                            if (fetchItem.pos >= delayInfo.top && fetchItem.pos <= delayInfo.bottom) {
                                                var newevent = {
                                                    entityCollection: entityCollection,
                                                    result: entityCollection,
                                                    position: fetchItem.pos,
                                                    entity: null
                                                };
                                                WAF.callHandler(true, event.error, newevent, fetchItem.options, fetchItem.userData);
                                            }
                                        });
                                        delayInfo.removePendingRequest(delayReq);
                                    },
                                    init: forceCollectionRefresh,
                                    addToSet: newOptions.addToSet || null
                                });
                            } else delayInfo.removePendingRequest(delayReq);
                        }, delay);
                        delayReq.setRequestID(requestid);
                    } else delayReq.addFetchRequest(pos, options, userData);
                } else {
                    var newOptions = {};
                    if (forceCollectionRefresh) priv.updateOptions(newOptions);
                    priv.fetchData(pos, priv.pageSize, {
                        onSuccess: function(event) {
                            if (forceCollectionRefresh) priv.addedElems = [];
                            var key = priv.getKeyByPos(pos);
                            var cacheRef = dataClass.mustCacheRef();
                            var cache;
                            if (cacheRef) cache = dataClass.getRefCache(); else cache = dataClass.getCache();
                            var cacheInfo = cache.getCacheInfo(key);
                            if (null != cacheInfo) priv.gotEntity(cacheInfo, options, userData, pos); else priv.gotEntity(null, options, userData);
                        },
                        onError: function(event) {
                            var newevent = {
                                entityCollection: entityCollection,
                                result: entityCollection,
                                position: pos,
                                entity: null
                            };
                            WAF.callHandler(true, event.error, newevent, options, userData);
                        },
                        init: forceCollectionRefresh,
                        addToSet: newOptions.addToSet || null
                    });
                }
            }
        }
        return executed;
    };
    WAF.EntityCollection.gotEntity = function(cacheInfo, options, userData, position) {
        var priv = this;
        var entityCollection = priv.owner;
        var entity;
        if (null != cacheInfo) if (null != cacheInfo.entity) entity = cacheInfo.entity; else entity = new WAF.Entity(entityCollection.getDataClass(), cacheInfo.rawEntity, {
            getRefFromCache: true
        }); else entity = null;
        var event = {
            entityCollection: entityCollection,
            result: entity,
            entity: entity,
            position: position
        };
        WAF.callHandler(false, null, event, options, userData);
    };
    WAF.EntityCollection.callMethod = function(options) {
        var entityCollection = this;
        var methodRef = entityCollection._private.methodRefs[options.method];
        if (null != methodRef) {
            var myargs = [];
            if (null != options.arguments) myargs = options.arguments; else for (var i = 1, nb = arguments.length; i < nb; i++) myargs.push(arguments[i]);
            return WAF.DataStore.funcCaller(methodRef, entityCollection, myargs, options);
        }
    };
    WAF.EntityCollection.parseForEach = function(options, parseData) {
        var executed = true;
        var entityCollection = parseData.entityCollection;
        var priv = entityCollection._private;
        var stop = false;
        while (executed && parseData.curelem < parseData.limit && !stop) {
            executed = entityCollection.getEntity(parseData.curelem, options, parseData.userData, true);
            if (null != options && options.mustStopLoop) stop = true; else if (executed) parseData.curelem++; else entityCollection.getEntity(parseData.curelem, {
                onSuccess: function(event) {
                    WAF.EntityCollection.parseForEach(options, parseData);
                },
                onError: function(event) {
                    WAF.callHandler(true, event.error, event, options, parseData.userData);
                }
            }, parseData);
        }
        if (executed) if (null != options.atTheEnd) {
            var event = {
                entityCollection: entityCollection,
                userData: parseData.userData
            };
            options.atTheEnd(event);
        }
        return executed;
    };
    WAF.EntityCollection.forEach = function(options, userData) {
        var entityCollection = this;
        var priv = entityCollection._private;
        var resOp = WAF.tools.handleArgs(arguments, 0, {
            with3funcs: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var limit = entityCollection.length;
        if (null != options.limit && options.limit < limit) limit = options.limit;
        var parseInfo = {
            curelem: options.first || 0,
            limit: limit,
            userData: userData,
            entityCollection: entityCollection
        };
        WAF.EntityCollection.parseForEach(options, parseInfo);
    };
    WAF.EntityCollection.forEachInCache = function(options, userData) {
        var entityCollection = this;
        var priv = entityCollection._private;
        var resOp = WAF.tools.handleArgs(arguments, 0, {
            with3funcs: true
        });
        userData = resOp.userData;
        options = resOp.options;
        var stop = false;
        var curpagenum = -1;
        var nbpage = priv.pages.length;
        var curelem = 0;
        var nbelem = 0;
        var curpage = null;
        var curstart = 0;
        var absolutestart = options.first || 0;
        var absoluteend = entityCollection.length;
        if (null != options.limit && options.limit < absoluteend) absoluteend = options.limit;
        while (!stop) {
            if (curelem >= nbelem) {
                ++curpagenum;
                if (curpagenum >= nbpage) stop = true; else {
                    curpage = priv.pages[curpagenum];
                    nbelem = curpage.length;
                    curelem = 0;
                    curstart = curpage.start;
                }
            } else ++curelem;
            if (!stop) {
                var pos = curstart + curelem;
                if (pos >= absolutestart) if (pos < absoluteend) entityCollection.getEntity(pos, options, userData, true); else stop = true;
            }
        }
    };
    WAF.EntityCollection.add = function(entity) {
        if (null != entity) {
            this._private.addedElems.push(entity);
            this.length++;
        }
    };
    WAF.EntityCollection.refresh = function(options, userData) {
        options = options || {};
        options.forceCollectionRefresh = true;
        var from = 0;
        if (null != options.refreshCollectionFrom) from = options.refreshCollectionFrom;
        userData = userData;
        this.getEntity(from, options, userData);
    };
    WAF.EntityCollection.toArray = function(attributeList, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getNameForRest();
        request.top = options.top || priv.pageSize || 40;
        request.skip = options.skip || null;
        request.params = priv.params;
        request.addToSet = options.addToSet;
        request.retainPositions = options.retainPositions || null;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        request.orderby = options.orderby;
        request.autoExpand = attributeList;
        request.asArray = true;
        if (options.filterQuery) {
            request.filter = options.filterQuery;
            request.params = options.params;
        }
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                result: rawResult,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.distinctValues = function(attributeName, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getNameForRest();
        request.addToSet = options.addToSet;
        request.top = options.top || null;
        request.skip = options.skip || null;
        request.params = priv.params;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        request.distinct = true;
        if (null != attributeName) request.attributesRequested = [ attributeName ];
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                distinctValues: rawResult,
                result: rawResult,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.findKey = function(key, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getNameForRest();
        request.addToSet = options.addToSet;
        request.top = options.top || null;
        request.skip = options.skip || null;
        request.params = priv.params;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        if (key instanceof Date) key = key.toISO();
        request.findKey = key;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                result: rawResult.result,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.removeEntityReference = function(posInSet, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        options.removeReferenceOnly = true;
        this.removeEntity(posInSet, options, userData);
    };
    WAF.EntityCollection.removeEntity = function(posInSet, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        options.dataURI = priv.dataURI;
        var dataClass = entityCollection.getDataClass();
        if (posInSet >= priv.loadedElemsLength && posInSet < entityCollection.length) {
            var subpos = posInSet - priv.loadedElemsLength;
            var entity = priv.addedElems[subpos];
            var resev = {
                entityCollection: entityCollection,
                result: entityCollection
            };
            if (null == entity || null == entity.getKey() || options.removeReferenceOnly) {
                priv.addedElems.splice(subpos, 1);
                entityCollection.length--;
                WAF.callHandler(false, null, resev, options, userData);
            } else entity.remove({
                onSuccess: function(ev) {
                    priv.addedElems.splice(subpos, 1);
                    entityCollection.length--;
                    WAF.callHandler(false, null, resev, options, userData);
                },
                onError: function(ev) {
                    WAF.callHandler(true, ev.error, resev, options, userData);
                }
            });
        } else {
            options.pageSize = options.pageSize || priv.pageSize;
            options.autoExpand = options.autoExpand || priv.autoExpand;
            options.filterAttributes = options.filterAttributes || priv.filterAttributes;
            priv.updateOptions(options);
            options.removeAtPos = posInSet;
            options.savedQuery = priv.savedQuery || null;
            options.savedOrderby = priv.savedOrderby || null;
            var newEntityCollection = new WAF.EntityCollection(dataClass, null, options, userData);
            return newEntityCollection;
        }
    };
    WAF.EntityCollection.removeAllEntities = function(options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        priv.updateOptions(options);
        var request = new WAF.core.restConnect.restRequest(true);
        request.entityCollection = entityCollection;
        request.resource = priv.dataClass.getNameForRest();
        request.addToSet = options.addToSet;
        request.params = priv.params;
        request.progressInfo = options.progressInfo || priv.progressInfo;
        request.savedOrderby = priv.savedOrderby;
        request.savedQueryString = priv.savedQuery;
        request.dataURI = priv.dataURI;
        request.method = "delete";
        request.atOnce = options.atOnce;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var rawResult = WAF.getRequestResult(request);
            var event = {
                entityCollection: entityCollection,
                XHR: request.http_request
            };
            var withError = null != rawResult.__ERROR;
            WAF.callHandler(withError, rawResult.__ERROR, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.EntityCollection.buildFromSelection = function(selection, options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var entityCollection = this;
        var priv = entityCollection._private;
        var dataClass = entityCollection.getDataClass();
        options.pageSize = options.pageSize || priv.pageSize;
        options.autoExpand = options.autoExpand || priv.autoExpand;
        options.filterAttributes = options.filterAttributes || priv.filterAttributes;
        priv.updateOptions(options);
        options.filterSet = entityCollection;
        options.fromSelection = selection;
        options.savedQuery = priv.savedQuery || null;
        options.savedOrderby = priv.savedOrderby || null;
        var subEntityCollection = new WAF.EntityCollection(dataClass, null, options, userData);
        return subEntityCollection;
    };
    WAF.EntityAttributeSimple = function(entity, rawVal, att) {
        this.owner = entity;
        if ("date" === att.type && "string" === typeof rawVal) if (att.simpleDate) this.value = stringToSimpleDate(rawVal); else this.value = ISOToDate(rawVal); else this.value = rawVal;
        if ("blob" === att.type || "image" === att.type) {
            att.unResolvedFile = null;
            att.resolvedID = null;
        }
        this.touched = false;
        this.att = att;
        this.getValue = WAF.EntityAttributeSimple.getValue;
        this.setValue = WAF.EntityAttributeSimple.setValue;
        this.touch = WAF.EntityAttributeSimple.touch;
        this.isTouched = WAF.EntityAttributeSimple.isTouched;
        this.clearTouched = WAF.EntityAttributeSimple.clearTouched;
        this.getOldValue = WAF.EntityAttributeSimple.getOldValue;
        this.setRawValue = WAF.EntityAttributeSimple.setRawValue;
        this.getRawValue = WAF.EntityAttributeSimple.getRawValue;
        this.resolveFile = WAF.EntityAttributeSimple.resolveFile;
    };
    WAF.EntityAttributeSimple.getValue = function() {
        return this.value;
    };
    WAF.EntityAttributeSimple.setValue = function(val) {
        if ("blob" === this.att.type || "image" === this.att.type) {
            this.unResolvedFile = val;
            this.resolvedID = null;
            this.touch();
        } else {
            if (void 0 === this.oldValue) this.oldValue = this.value;
            this.value = val;
            this.touch();
        }
    };
    WAF.EntityAttributeSimple.resolveFile = function(options, userData) {
        var valatt = this;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        if (null != this.unResolvedFile) {
            var request = new WAF.core.restConnect.restRequest(true);
            request.resource = "$upload";
            request.httpMethod = WAF.core.restConnect.httpMethods._post;
            request.postdata = this.unResolvedFile;
            request.postAFile = true;
            request.handler = function() {
                if (4 != request.http_request.readyState) return;
                var error = false;
                var err = null;
                var result = WAF.getRequestResult(request);
                var finalresult = null;
                if (null != result.__ERROR) {
                    error = true;
                    err = result.__ERROR;
                } else {
                    finalresult = result;
                    if (null != result.ID) {
                        valatt.unResolvedFile = null;
                        valatt.resolvedID = result.ID;
                    }
                }
                var event = {
                    result: finalresult
                };
                WAF.callHandler(error, err, event, options, userData);
            };
            request.go();
        } else {
            var event = {
                result: null
            };
            WAF.callHandler(true, {
                error: 602,
                errorMessage: "no file to resolve"
            }, event, options, userData);
        }
    };
    WAF.EntityAttributeSimple.touch = function() {
        this.touched = true;
        this.owner.touch();
    };
    WAF.EntityAttributeSimple.clearTouched = function() {
        this.touched = false;
    };
    WAF.EntityAttributeSimple.isTouched = function() {
        return this.touched;
    };
    WAF.EntityAttributeSimple.getOldValue = function() {
        if (void 0 === this.oldValue) return this.getValue(); else return this.oldValue;
    };
    WAF.EntityAttributeSimple.setRawValue = function(rawVal) {
        if ("date" === this.att.type && "string" === typeof rawVal) if (this.att.simpleDate) this.value = stringToSimpleDate(rawVal); else this.value = ISOToDate(rawVal); else this.value = rawVal;
        if ("blob" === this.att.type || "image" === this.att.type) {
            this.unResolvedFile = null;
            this.resolvedID = null;
        }
        delete this.oldValue;
    };
    WAF.EntityAttributeSimple.getRawValue = function() {
        var result = this.value;
        if (null != this.resolvedID) result = {
            ID: this.resolvedID
        }; else if (null != result && "date" === this.att.type) if (this.att.simpleDate) result = result.toSimpleDateString(); else result = result.toISO();
        return result;
    };
    WAF.EntityAttributeRelated = function(entity, rawVal, att) {
        WAF.EntityAttributeSimple.call(this, entity, rawVal, att);
        if (null != rawVal) if (null != rawVal.__deferred) {
            this.relEntity = null;
            this.dataURI = rawVal.__deferred.uri;
            this.relKey = rawVal.__deferred.__KEY;
        } else {
            var relClass = att.getRelatedClass();
            if (null == relClass) {
                this.relEntity = null;
                this.dataURI = null;
                this.relKey = null;
            } else {
                this.relEntity = new WAF.Entity(relClass, rawVal, {
                    getRefFromCache: true
                });
                this.dataURI = null;
                this.relKey = null;
            }
        } else {
            this.relEntity = null;
            this.dataURI = null;
            this.relKey = null;
        }
        this.setValue = WAF.EntityAttributeRelated.setValue;
        this.getValue = WAF.EntityAttributeRelated.getValue;
        this.load = this.getValue;
        this.setRawValue = WAF.EntityAttributeRelated.setRawValue;
        this.getRawValue = WAF.EntityAttributeRelated.getRawValue;
        this.getOldValue = WAF.EntityAttributeRelated.getOldValue;
        this.getRelatedKey = WAF.EntityAttributeRelated.getRelatedKey;
    };
    WAF.EntityAttributeRelated.getRelatedKey = function() {
        var key = null;
        if (null == this.relEntity) key = this.relKey; else key = this.relEntity.getKey();
        return key;
    };
    WAF.EntityAttributeRelated.getOldValue = function() {
        if (void 0 === this.oldValue) return this.getValue(); else return this.oldValue;
    };
    WAF.EntityAttributeRelated.getValue = function(options, userData) {
        if (null == options) return this.relEntity; else {
            var resOp = WAF.tools.handleArgs(arguments, 0);
            userData = resOp.userData;
            options = resOp.options;
            var val = this;
            var event = {
                entity: null
            };
            if (null == val.relEntity) if (null == val.dataURI && null == val.relKey) WAF.callHandler(false, null, event, options, userData); else {
                var relClass = val.att.getRelatedClass();
                if (null == relClass) WAF.callHandler(false, null, event, options, userData); else if (null != val.relKey) relClass.getEntity(val.relKey, {
                    onSuccess: function(event) {
                        val.relEntity = event.entity;
                        WAF.callHandler(false, null, event, options, userData);
                    },
                    onError: function(event) {
                        WAF.callHandler(true, event.error, event, options, userData);
                    },
                    autoExpand: options.autoExpand
                }); else relClass.getEntityByURI(val.dataURI, {
                    onSuccess: function(event) {
                        val.relEntity = event.entity;
                        WAF.callHandler(false, null, event, options, userData);
                    },
                    onError: function(event) {
                        WAF.callHandler(true, event.error, event, options, userData);
                    },
                    autoExpand: options.autoExpand
                });
            } else {
                event.entity = val.relEntity;
                WAF.callHandler(false, null, event, options, userData);
            }
        }
    };
    WAF.EntityAttributeRelated.setValue = function(relatedEntity) {
        if (void 0 === this.oldValue) this.oldValue = this.relEntity;
        this.relEntity = relatedEntity;
        this.touched = true;
        this.owner.touch();
        this.dataURI = null;
        if (null == relatedEntity) this.relKey = null; else if (relatedEntity instanceof WAF.Entity) this.relKey = relatedEntity.getKey(); else if (this.relKey !== relatedEntity) {
            this.relEntity = null;
            this.relKey = relatedEntity;
        }
    };
    WAF.EntityAttributeRelated.setRawValue = function(rawVal) {
        if (null != rawVal) if (null != rawVal.__deferred) {
            this.relEntity = null;
            this.dataURI = rawVal.__deferred.uri;
            this.relKey = rawVal.__deferred.__KEY;
        } else {
            var relClass = this.att.getRelatedClass();
            if (null == relClass) {
                this.relEntity = null;
                this.dataURI = null;
                this.relKey = null;
            } else {
                this.relEntity = new WAF.Entity(relClass, rawVal, {
                    getRefFromCache: true
                });
                this.dataURI = null;
                this.relKey = null;
            }
        } else {
            this.relEntity = null;
            this.dataURI = null;
            this.relKey = null;
        }
        delete this.oldValue;
    };
    WAF.EntityAttributeRelated.getRawValue = function() {
        var key = this.relKey;
        if (this.relEntity) key = this.relEntity.getKey();
        if (null != key) return {
            __KEY: key
        }; else if (this.relEntity) return this.relEntity._private.getRESTFormat();
        return null;
    };
    WAF.EntityAttributeRelatedSet = function(entity, rawVal, att) {
        WAF.EntityAttributeSimple.call(this, entity, rawVal, att);
        if (null != rawVal) if (null != rawVal.__deferred) {
            this.relEntityCollection = null;
            this.dataURI = rawVal.__deferred.uri;
        } else {
            var relClass = att.getRelatedClass();
            if (null == relClass) {
                this.relEntityCollection = null;
                this.dataURI = null;
            } else {
                this.relEntityCollection = new WAF.EntityCollection(relClass, null, {
                    prefetchedData: rawVal
                });
                this.dataURI = this.relEntityCollection._private.dataURI;
            }
        } else {
            this.relEntityCollection = null;
            this.dataURI = null;
        }
        this.setValue = WAF.EntityAttributeRelatedSet.setValue;
        this.getValue = WAF.EntityAttributeRelatedSet.getValue;
        this.setRawValue = WAF.EntityAttributeRelatedSet.setRawValue;
    };
    WAF.EntityAttributeRelatedSet.setRawValue = function(rawVal) {
        if (null != rawVal) if (null != this.dataURI && rawVal.__deferred == this.dataURI) ; else if (null != rawVal.__deferred) {
            this.relEntityCollection = null;
            this.dataURI = rawVal.__deferred.uri;
        } else {
            var relClass = this.att.getRelatedClass();
            if (null == relClass) {
                this.relEntityCollection = null;
                this.dataURI = null;
            } else {
                this.relEntityCollection = new WAF.EntityCollection(relClass, null, {
                    prefetchedData: rawVal
                });
                this.dataURI = this.relEntityCollection._private.dataURI;
            }
        } else {
            this.relEntityCollection = null;
            this.dataURI = null;
        }
    };
    WAF.EntityAttributeRelatedSet.getValue = function(options, userData) {
        if (null == options) return this.relEntityCollection; else {
            var resOp = WAF.tools.handleArgs(arguments, 0);
            userData = resOp.userData;
            options = resOp.options;
            var relSet = null;
            var val = this;
            var event = {
                entityCollection: null
            };
            if (null != this.relEntityCollection) {
                relSet = this.relEntityCollection;
                if (relSet._private.ready) {
                    event.entityCollection = relSet;
                    WAF.callHandler(false, null, event, options, userData);
                } else {
                    var funcToCall = function() {
                        if (relSet._private.ready) {
                            event.entityCollection = relSet;
                            WAF.callHandler(false, null, event, options, userData);
                        } else setTimeout(funcToCall, 100);
                    };
                    setTimeout(funcToCall, 100);
                }
            } else {
                var relClass = this.att.getRelatedClass();
                if (null == relClass) WAF.callHandler(true, {
                    error: 601,
                    errorMessage: "wrong entityCollection reference"
                }, event, options, userData); else {
                    if (null == this.dataURI) this.dataURI = "*";
                    options.isARelatedEntityCollection = true;
                    options.dataURI = this.dataURI;
                    this.relEntityCollection = new WAF.EntityCollection(relClass, null, options, userData);
                    relSet = this.relEntityCollection;
                }
            }
            return relSet;
        }
    };
    WAF.Entity = function(dataClass, rawData, options) {
        var entity = this;
        options = options || {};
        var tryToGetRefFromCache = (options.getRefFromCache || false) && dataClass.mustCacheRef();
        var mergeExistingEntity = tryToGetRefFromCache && null != rawData;
        var cache;
        var cacheInfo = null;
        var key;
        if (tryToGetRefFromCache && null != rawData) {
            cache = dataClass.getRefCache();
            key = rawData.__KEY;
            if (null != key) {
                cacheInfo = cache.getCacheInfo(key);
                if (null != cacheInfo) if (rawData.__STAMP === cacheInfo.entity.getStamp()) {
                    cacheInfo.timeStamp = new Date();
                    entity = cacheInfo.entity;
                    if (mergeExistingEntity) {
                        var attsByName = dataClass._private.attributesByName;
                        for (var e in attsByName) {
                            var att = attsByName[e];
                            var val = rawData[e];
                            if (void 0 != val) {
                                valAtt = entity[e];
                                if (!att.related) valAtt.setRawValue(val); else if (att.relatedOne) {
                                    if (null != val && null == val.__deferred) valAtt.setRawValue(val);
                                } else if (null != val && null == val.__deferred) valAtt.setRawValue(val);
                            }
                        }
                    }
                    return entity;
                }
            }
        }
        this._private = {
            touched: false,
            isNew: true,
            dataClass: dataClass,
            owner: this,
            values: {},
            methodRefs: dataClass._private.entityMethodRefs,
            methods: dataClass._private.entityMethods,
            getRESTFormat: WAF.Entity.getRESTFormat,
            getListOfUnresolvedIDs: WAF.Entity.getListOfUnresolvedIDs
        };
        var priv = this._private;
        var methods = priv.methods;
        for (var e in methods) entity[e] = methods[e];
        this.touch = WAF.Entity.touch;
        this.getDataClass = WAF.Entity.getDataClass;
        this.getKey = WAF.Entity.getKey;
        this.setStamp = WAF.Entity.setStamp;
        this.setKey = WAF.Entity.setKey;
        this.getStamp = WAF.Entity.getStamp;
        this.callMethod = WAF.Entity.callMethod;
        this.isNew = WAF.Entity.isNew;
        this.isTouched = WAF.Entity.isTouched;
        this.save = WAF.Entity.save;
        this.remove = WAF.Entity.remove;
        this.lock = WAF.Entity.lock;
        this.unlock = WAF.Entity.unlock;
        this._dolock = WAF.Entity._dolock;
        this.serverRefresh = WAF.Entity.serverRefresh;
        var isnew = false;
        if (null == rawData || null == rawData.__KEY) {
            this._private.key = null;
            this._private.stamp = 0;
            this._private.isNew = true;
            isnew = true;
            if (null != rawData) this._private.touched = true;
        } else {
            this._private.key = rawData.__KEY;
            this._private.stamp = rawData.__STAMP;
            this._private.isNew = false;
        }
        var values = entity._private.values;
        var attsByName = dataClass._private.attributesByName;
        for (var e in attsByName) {
            var att = attsByName[e];
            var val = null == rawData ? null : null == rawData[e] ? null : rawData[e];
            var valAtt;
            if (!att.related) valAtt = new WAF.EntityAttributeSimple(entity, val, att); else if (att.relatedOne) valAtt = new WAF.EntityAttributeRelated(entity, val, att); else valAtt = new WAF.EntityAttributeRelatedSet(entity, val, att);
            if (isnew && null != val) valAtt.touched = true;
            values[e] = valAtt;
            entity[e] = valAtt;
        }
        if (tryToGetRefFromCache && null != rawData) {
            cache.setEntry(entity);
            if (null != cacheInfo) return cacheInfo.entity;
        }
    };
    WAF.Entity.getRESTFormat = function(overrideStamp) {
        var priv = this;
        var entity = this.owner;
        var result = {};
        var key = entity.getKey();
        if (null != key) {
            result.__KEY = key;
            result.__STAMP = entity.getStamp();
            if (overrideStamp) result.__STAMP = -result.__STAMP;
        } else result.__ISNEW = true;
        for (var e in priv.values) {
            var valAtt = priv.values[e];
            if (valAtt.isTouched()) result[e] = valAtt.getRawValue();
        }
        return result;
    };
    WAF.Entity.getListOfUnresolvedIDs = function() {
        var priv = this;
        var entity = this.owner;
        var result = [];
        for (var e in priv.values) {
            var valAtt = priv.values[e];
            if (valAtt.isTouched() && null != valAtt.unResolvedFile) result.push(e);
        }
        return result;
    };
    WAF.Entity.touch = function() {
        this._private.touched = true;
    };
    WAF.Entity.getDataClass = function() {
        return this._private.dataClass;
    };
    WAF.Entity.getKey = function() {
        return this._private.key;
    };
    WAF.Entity.getStamp = function() {
        return this._private.stamp;
    };
    WAF.Entity.setKey = function(key) {
        this._private.key = key;
    };
    WAF.Entity.setStamp = function(stamp) {
        this._private.stamp = stamp;
    };
    WAF.Entity.callMethod = function(options) {
        var entity = this;
        var methodRef = entity._private.methodRefs[options.method];
        if (null != methodRef) {
            var myargs = [];
            if (null != options.arguments) myargs = options.arguments; else for (var i = 1, nb = arguments.length; i < nb; i++) myargs.push(arguments[i]);
            return WAF.DataStore.funcCaller(methodRef, entity, myargs, options);
        }
    };
    WAF.Entity.isNew = function() {
        return this._private.isNew;
    };
    WAF.Entity.isTouched = function() {
        return this._private.touched;
    };
    WAF.Entity.serverRefresh = function(options, userData) {
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        options.refreshOnly = true;
        this.save(options, userData);
    };
    WAF.Entity.lock = function(options, userdata) {
        this._dolock(true, options || null, userdata || null);
    };
    WAF.Entity.unlock = function(options, userdata) {
        this._dolock(false, options || null, userdata || null);
    };
    WAF.Entity._dolock = function(mustlock, options, userdata) {
        var entity = this;
        var resOp = WAF.tools.handleArgs(arguments, 1);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = entity.getDataClass();
        var dataClassName = dataClass.getNameForRest();
        var key = entity.getKey();
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClassName + "(" + key + ")";
        request.mustlock = mustlock;
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var lockresult = false;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            } else lockresult = result.result;
            var event = {
                entity: entity,
                result: lockresult
            };
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.Entity.remove = function(options, userData) {
        var entity = this;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = entity.getDataClass();
        var dataClassName = dataClass.getNameForRest();
        var key = entity.getKey();
        var request = new WAF.core.restConnect.restRequest(true);
        request.resource = dataClassName + "(" + key + ")";
        request.method = "delete";
        request.handler = function() {
            if (4 != request.http_request.readyState) return;
            var error = false;
            var err = null;
            var result = WAF.getRequestResult(request);
            if (null != result.__ERROR) {
                error = true;
                err = result.__ERROR;
            } else dataClass.getCache().removeCachedEntity(key);
            var event = {
                entity: entity
            };
            WAF.callHandler(error, err, event, options, userData);
        };
        var errorFlag = request.go();
    };
    WAF.Entity.save = function(options, userData) {
        var entity = this;
        var resOp = WAF.tools.handleArgs(arguments, 0);
        userData = resOp.userData;
        options = resOp.options;
        var dataClass = entity.getDataClass();
        var dataClassName = dataClass.getNameForRest();
        var refreshOnly = options.refreshOnly;
        if (null == refreshOnly) refreshOnly = false;
        var unresolvedIDs = entity._private.getListOfUnresolvedIDs();
        var currentUnresolved = 0;
        resolveNext();
        function resolveNext() {
            if (currentUnresolved >= unresolvedIDs.length) finalSave(); else {
                var attname = unresolvedIDs[currentUnresolved];
                entity[attname].resolveFile({
                    onSuccess: function(ev) {
                        ++currentUnresolved;
                        resolveNext();
                    },
                    onError: function(ev) {
                        var event = {
                            entity: entity,
                            rawResult: null,
                            XHR: null
                        };
                        WAF.callHandler(true, ev.error, event, options, userData);
                    }
                });
            }
        }
        function finalSave() {
            var request = new WAF.core.restConnect.restRequest(true);
            request.resource = dataClassName;
            var key = entity.getKey();
            if (null == key) {
                request.method = "update";
                request.httpMethod = WAF.core.restConnect.httpMethods._post;
            } else {
                request.method = "update";
                request.httpMethod = WAF.core.restConnect.httpMethods._post;
            }
            request.postdata = '{ "__ENTITIES": [' + JSON.stringify(entity._private.getRESTFormat(options.overrideStamp)) + "]}";
            request.refreshOnly = refreshOnly;
            if (null != options.autoExpand) request.autoExpand = options.autoExpand;
            if (null != options.filterAttributes) request.filterAttributes = options.filterAttributes;
            request.handler = function() {
                if (4 != request.http_request.readyState) return;
                var rawResult = WAF.getRequestResult(request);
                var event = {
                    entity: entity,
                    rawResult: rawResult,
                    XHR: request.http_request
                };
                var rawResult = JSON.parse(request.http_request.responseText);
                var withError = false;
                var err = null;
                if (rawResult) if (rawResult.__ENTITIES) if (rawResult.__ENTITIES[0]) {
                    var rawResultRec = rawResult.__ENTITIES[0];
                    if (rawResultRec.__ERROR) {
                        err = rawResultRec.__ERROR;
                        withError = true;
                    } else {
                        var oldKEY = key;
                        var newKEY = rawResultRec.__KEY;
                        if (!refreshOnly) {
                            if (null != newKEY) entity._private.key = newKEY;
                            entity._private.stamp = rawResultRec.__STAMP;
                        }
                        var attsByName = dataClass._private.attributesByName;
                        for (var e in attsByName) {
                            var att = attsByName[e];
                            var val = rawResultRec[e];
                            if (void 0 === val) val = null;
                            var valAtt = entity[e];
                            if (null == valAtt) {
                                if (!att.related) valAtt = new WAF.EntityAttributeSimple(entity, val, att); else if (att.relatedOne) valAtt = new WAF.EntityAttributeRelated(entity, val, att); else valAtt = new WAF.EntityAttributeRelatedSet(entity, val, att);
                                entity[e] = valAtt;
                            } else {
                                if (true || valAtt.isTouched()) valAtt.setRawValue(val);
                                if (!refreshOnly) valAtt.clearTouched();
                            }
                        }
                        if (dataClass.mustCacheRef()) dataClass.getRefCache().setEntry(entity); else dataClass.getCache().replaceCachedEntity(newKEY, rawResultRec);
                        if (!refreshOnly) {
                            entity._private.touched = false;
                            entity._private.isNew = false;
                        }
                    }
                }
                WAF.callHandler(withError, err, event, options, userData);
            };
            var errorFlag = request.go();
        }
    };
    WAF.EntityCollection.prototype.getDataClass = WAF.EntityCollection.getDataClass;
    WAF.EntityCollection.prototype.query = WAF.EntityCollection.query;
    WAF.EntityCollection.prototype.getEntity = WAF.EntityCollection.getEntity;
    WAF.EntityCollection.prototype.getEntities = WAF.EntityCollection.getEntities;
    WAF.EntityCollection.prototype.callMethod = WAF.EntityCollection.callMethod;
    WAF.EntityCollection.prototype.each = WAF.EntityCollection.forEach;
    WAF.EntityCollection.prototype.forEach = WAF.EntityCollection.forEach;
    WAF.EntityCollection.prototype.forEachInCache = WAF.EntityCollection.forEachInCache;
    WAF.EntityCollection.prototype.add = WAF.EntityCollection.add;
    WAF.EntityCollection.prototype.orderBy = WAF.EntityCollection.orderBy;
    WAF.EntityCollection.prototype.toArray = WAF.EntityCollection.toArray;
    WAF.EntityCollection.prototype.distinctValues = WAF.EntityCollection.distinctValues;
    WAF.EntityCollection.prototype.findKey = WAF.EntityCollection.findKey;
    WAF.EntityCollection.prototype.removeEntity = WAF.EntityCollection.removeEntity;
    WAF.EntityCollection.prototype.removeEntityReference = WAF.EntityCollection.removeEntityReference;
    WAF.EntityCollection.prototype.removeAllEntities = WAF.EntityCollection.removeAllEntities;
    WAF.EntityCollection.prototype.buildFromSelection = WAF.EntityCollection.buildFromSelection;
    WAF.EntityCollection.prototype.getReference = WAF.EntityCollection.getReference;
    WAF.EntityCollection.prototype.refresh = WAF.EntityCollection.refresh;
    WAF.DataClass.prototype.distinctValues = WAF.DataClass.distinctValues;
    WAF.DataClass.prototype.all = WAF.DataClass.allEntities;
    WAF.DataClass.prototype.allEntities = WAF.DataClass.allEntities;
    WAF.DataClass.prototype.query = WAF.DataClass.query;
    WAF.DataClass.prototype.find = WAF.DataClass.find;
    WAF.DataClass.prototype.getAttributeByName = WAF.DataClass.getAttributeByName;
    WAF.DataClass.prototype.getAttributes = WAF.DataClass.getAttributes;
    WAF.DataClass.prototype.getMethodList = WAF.DataClass.getMethodList;
    WAF.DataClass.prototype.getCache = WAF.DataClass.getCache;
    WAF.DataClass.prototype.getRefCache = WAF.DataClass.getRefCache;
    WAF.DataClass.prototype.getCacheSize = WAF.DataClass.getCacheSize;
    WAF.DataClass.prototype.setCacheSize = WAF.DataClass.setCacheSize;
    WAF.DataClass.prototype.clearCache = WAF.DataClass.clearCache;
    WAF.DataClass.prototype.newEntity = WAF.DataClass.newEntity;
    WAF.DataClass.prototype.getEntity = WAF.DataClass.getEntity;
    WAF.DataClass.prototype.getEntityByURI = WAF.DataClass.getEntityByURI;
    WAF.DataClass.prototype.getDataStore = WAF.DataClass.getDataStore;
    WAF.DataClass.prototype.getCollectionName = WAF.DataClass.getCollectionName;
    WAF.DataClass.prototype.getDefaultTopSize = WAF.DataClass.getDefaultTopSize;
    WAF.DataClass.prototype.getName = WAF.DataClass.getName;
    WAF.DataClass.prototype.getNameForRest = WAF.DataClass.getNameForRest;
    WAF.DataClass.prototype.newCollection = WAF.DataClass.newCollection;
    WAF.DataClass.prototype.toArray = WAF.DataClass.toArray;
    WAF.DataClass.prototype.mustCacheRef = WAF.DataClass.mustCacheRef;
    WAF.DataClass.prototype.callMethod = WAF.DataStore.callMethod;
    WAF.directory = WAF.directory || {};
    WAF.directory.login = WAF.DataStore.makeFuncCaller({
        name: "login",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.loginByPassword = WAF.directory.login;
    WAF.directory.logout = WAF.DataStore.makeFuncCaller({
        name: "logout",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.loginByKey = WAF.DataStore.makeFuncCaller({
        name: "loginByKey",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.currentUser = WAF.DataStore.makeFuncCaller({
        name: "currentUser",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.directory.currentUserBelongsTo = WAF.DataStore.makeFuncCaller({
        name: "currentUserBelongsTo",
        applyTo: "general",
        nameSpace: "$directory"
    });
    WAF.dsExport = WAF.dsExport || {};
    WAF.dsExport.exportData = WAF.DataStore.makeFuncCaller({
        name: "exportData",
        applyTo: "general",
        nameSpace: "$impexp"
    });
    var wakanda = angular.module("wakanda", []);
    wakanda.provider("$wakandaConfig", function() {
        var hostname = "";
        this.$get = function() {
            return {
                getHostname: function() {
                    return hostname;
                }
            };
        };
        this.setHostname = function(_hostname) {
            WAF.hostname = _hostname;
            hostname = _hostname;
        };
    });
    wakanda.factory("$wakanda", [ "$q", "$rootScope", "$http", "$wakandaConfig", function($q, $rootScope, $http, $wakandaConfig) {
        var ds = null, NgWakEntityClasses = {}, DEFAULT_PAGESIZE_NESTED_COLLECTIONS = 40;
        var $wakandaResult = {};
        $wakandaResult.init = function(catalog) {
            console.log(">$wakanda init");
            var deferred = $q.defer();
            deferred.promise.$promise = deferred.promise;
            if ("string" !== typeof catalog || "*" === catalog || "" === catalog) catalog = null;
            if (null === ds) new WAF.DataStore({
                onSuccess: function(event) {
                    ds = event.dataStore;
                    prepare.wafDatastore(ds);
                    prepare.wafDataClasses(ds);
                    deferred.resolve(ds);
                },
                onError: function(event) {
                    ds = null;
                    console.error(">$wakanda init > error", event);
                    deferred.reject(event);
                },
                catalog: catalog,
                cacheRef: false
            }); else deferred.resolve(ds);
            return deferred.promise;
        };
        $wakandaResult.getDatastore = function() {
            if (null !== ds) return ds; else throw new Error("The Datastore isn't initialized please execute .init(catalog) before you run your app.");
        };
        Object.defineProperty($wakandaResult, "$ds", {
            get: $wakandaResult.getDatastore
        });
        $wakandaResult.$loginByPassword = $wakandaResult.$login = function(login, password) {
            return _wrapInPromise(WAF.directory.loginByPassword, login, password);
        };
        $wakandaResult.$currentUser = function() {
            return _wrapInPromise(WAF.directory.currentUser);
        };
        $wakandaResult.$logout = function() {
            return _wrapInPromise(WAF.directory.logout);
        };
        $wakandaResult.$currentUserBelongsTo = function(groupName) {
            return _wrapInPromise(WAF.directory.currentUserBelongsTo, groupName);
        };
        $wakandaResult.$transform = {
            $objectToEntity: createNgWakEntity,
            $objectToCollection: function(wafEntityCollection, wakOptions) {
                var collection = [];
                transform.wafEntityCollectionToNgWakEntityCollection(collection, wafEntityCollection, wakOptions);
                return collection;
            }
        };
        function _wrapInPromise() {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.shift();
            var deferred, wakOptions = {};
            deferred = $q.defer();
            deferred.promise.$promise = deferred.promise;
            wakOptions.onSuccess = function(event) {
                deferred.resolve({
                    result: event.result
                });
            };
            wakOptions.onError = function(event) {
                deferred.reject(event);
            };
            args.push(wakOptions);
            callback.apply(this, args);
            return deferred.promise;
        }
        var rootScopeSafeApply = function(fn) {
            var phase = $rootScope.$$phase;
            if ("$apply" === phase || "$digest" === phase) {
                if (fn && "function" === typeof fn) fn();
            } else $rootScope.$apply(fn);
        };
        var prepare = {
            wafDatastore: function(dataStore) {
                dataStore.$Entity = NgWakEntityAbstract.prototype;
            },
            wafDataClasses: function(dataStore) {
                var dataClassName;
                WAF.DataClass.prototype.$query = $$query;
                WAF.DataClass.prototype.$find = $$find;
                WAF.DataClass.prototype.$create = $$create;
                WAF.DataClass.prototype.$all = $$all;
                for (dataClassName in dataStore) if (dataStore.hasOwnProperty(dataClassName) && "_private" !== dataClassName && "$" !== dataClassName[0]) {
                    prepare.wafDataClassAddMetas(dataStore[dataClassName]);
                    prepare.wafDataClassAddDataClassMethods(dataStore[dataClassName]);
                    prepare.wafDataClassCreateNgWakEntityClasses(dataStore[dataClassName]);
                }
            },
            wafDataClassAddMetas: function(dataClass) {
                var methodInfo, dataClassMethods = [], collectionMethods = [], entityMethods = [], attributes, attributeName;
                angular.forEach(dataClass.getMethodList(), function(methodInfo) {
                    switch (methodInfo.applyTo) {
                      case "entity":
                        entityMethods.push(methodInfo.name);
                        break;

                      case "entityCollection":
                        collectionMethods.push(methodInfo.name);
                        break;

                      case "dataClass":
                        dataClassMethods.push(methodInfo.name);
                    }
                });
                attributes = dataClass._private.attributesByName;
                dataClass.$attr = function(attrName) {
                    if ("undefined" === typeof attrName) return attributes; else if (attrName && attributes[attrName]) return attributes[attrName]; else return null;
                };
                dataClass.$dataClassMethods = function() {
                    return dataClassMethods;
                };
                dataClass.$collectionMethods = function() {
                    return collectionMethods;
                };
                dataClass.$entityMethods = function() {
                    return entityMethods;
                };
                dataClass.$name = dataClass.getName();
                dataClass.$collectionName = dataClass.getCollectionName();
                for (attributeName in attributes) if (true === attributes[attributeName].identifying) dataClass.$_identifyingAttr = attributes[attributeName];
                dataClass.$_relatedAttributes = dataClass.getAttributes().filter(function(attr) {
                    if ("relatedEntity" === attr.kind || "relatedEntities" === attr.kind) return attr;
                });
                dataClass.$_processedAttributes = dataClass.getAttributes().filter(function(attr) {
                    if ("calculated" === attr.kind || "alias" === attr.kind) return attr;
                });
            },
            wafDataClassAddDataClassMethods: function(dataClass) {
                prepareHelpers.createUserDefinedDataClassMethods(dataClass);
            },
            wafDataClassCreateNgWakEntityClasses: function(dataClass) {
                var proto;
                proto = prepareHelpers.createUserDefinedEntityMethods(dataClass);
                NgWakEntityClasses[dataClass.getName()] = NgWakEntityAbstract.extend(proto);
                dataClass.$Entity = NgWakEntityClasses[dataClass.getName()].prototype;
            }
        };
        var prepareHelpers = {
            createUserDefinedEntityMethods: function(dataClass) {
                var methodName, proto = {};
                for (methodName in dataClass._private.entityMethods) if (dataClass._private.entityMethods.hasOwnProperty(methodName)) {
                    proto[methodName + "Sync"] = function() {
                        return this.$_entity[methodName].apply(this.$_entity, arguments);
                    };
                    proto[methodName] = prepareHelpers.wakandaUserDefinedMethodToPromisableMethods(dataClass._private.entityMethods[methodName]);
                }
                return proto;
            },
            createUserDefinedEntityCollectionMethods: function(dataClass) {
                var methodName, proto = {};
                for (methodName in dataClass._private.entityCollectionMethods) if (dataClass._private.entityCollectionMethods.hasOwnProperty(methodName)) {
                    proto[methodName + "Sync"] = function() {
                        return this.$_collection[methodName].apply(this.$_collection, arguments);
                    };
                    proto[methodName] = prepareHelpers.wakandaUserDefinedMethodToPromisableMethods(dataClass._private.entityCollectionMethods[methodName]);
                }
                return proto;
            },
            createUserDefinedDataClassMethods: function(dataClass) {
                angular.forEach(dataClass.$dataClassMethods(), function(methodName) {
                    dataClass[methodName] = function() {
                        var defer = $q.defer();
                        defer.promise.$promise = defer.promise;
                        dataClass.callMethod({
                            method: methodName,
                            onSuccess: function(event) {
                                defer.resolve(event);
                            },
                            onError: function(error) {
                                console.error("userDataClassMethods.onError", "error", error);
                                defer.reject(error);
                            },
                            arguments: arguments.length > 0 ? Array.prototype.slice.call(arguments, 0) : []
                        });
                        return defer.promise;
                    };
                    dataClass[methodName + "Sync"] = function() {
                        return dataClass.callMethod({
                            method: methodName,
                            sync: true,
                            arguments: arguments.length > 0 ? Array.prototype.slice.call(arguments, 0) : []
                        });
                    };
                });
            },
            wakandaUserDefinedMethodToPromisableMethods: function(method) {
                return function() {
                    var thatArguments = [], that, wakOptions = {}, mode, deferred;
                    if (this instanceof NgWakEntityAbstract) {
                        if ("undefined" === typeof this.$_entity || !(this.$_entity instanceof WAF.Entity)) throw new Error("Calling user defined method on unfetched entity, please call $fetch before or retrieve data on $query");
                        mode = "$_entity";
                    } else mode = "$_collection";
                    if (arguments.length > 0) for (var i = 0; i < arguments.length; i++) thatArguments.push(arguments[i]);
                    deferred = $q.defer();
                    that = this;
                    deferred.promise.$promise = deferred.promise;
                    wakOptions.onSuccess = function(event) {
                        rootScopeSafeApply(function() {
                            deferred.resolve(event);
                        });
                    };
                    wakOptions.onError = function(error) {
                        rootScopeSafeApply(function() {
                            console.error("userMethods.onError", "error", error);
                            deferred.reject(error);
                        });
                    };
                    thatArguments.unshift(wakOptions);
                    if ("$_entity" === mode) method.apply(this[mode], thatArguments); else {
                        if (!this.$_collection) throw new Error("Couldn't call user defined method on collection because no pointer on this collection");
                        method.apply(this[mode], thatArguments);
                    }
                    return deferred.promise;
                };
            }
        };
        var transform = {
            wafEntityCollectionToNgWakEntityCollection: function(ngWakEntityCollection, wafEntityCollection, wakOptions) {
                wakOptions = "undefined" === typeof wakOptions ? {} : wakOptions;
                var mode = "undefined" === typeof mode || "replace" === mode ? "replace" : mode;
                var currentDataClass = wafEntityCollection.getDataClass();
                var start = "undefined" === typeof wakOptions.start ? 0 : wakOptions.start;
                var pageSize = "undefined" === typeof wakOptions.pageSize ? DEFAULT_PAGESIZE_NESTED_COLLECTIONS : wakOptions.pageSize;
                if ("undefined" === typeof ngWakEntityCollection.$_collection) {
                    ngWakEntityCollection.$_collection = wafEntityCollection;
                    transform.addFrameworkMethodsToRootCollection(ngWakEntityCollection);
                    transform.addUserDefinedMethodsToCollection(ngWakEntityCollection, true);
                }
                wafEntityCollection.forEachInCache({
                    onSuccess: function(item) {
                        ngWakEntityCollection.push(createNgWakEntity(item.entity));
                    },
                    first: start,
                    limit: start + pageSize
                });
            },
            addUserDefinedMethodsToCollection: function(result, root) {
                var userDefinedEntityCollectionMethods, dataClass = null;
                if (true === root) {
                    if ("undefined" !== typeof result.$_collection) dataClass = result.$_collection.getDataClass();
                } else if (false === root) if ("undefined" !== typeof result.$_collection && "undefined" !== result.$_collection.relEntityCollection) dataClass = result.$_collection.relEntityCollection;
                if (null === dataClass) return result;
                userDefinedEntityCollectionMethods = prepareHelpers.createUserDefinedEntityCollectionMethods(dataClass);
                for (var methodName in userDefinedEntityCollectionMethods) if (userDefinedEntityCollectionMethods.hasOwnProperty(methodName)) result[methodName] = userDefinedEntityCollectionMethods[methodName];
                return result;
            },
            addFrameworkMethodsToRootCollection: function(result) {
                result.$fetch = $$fetch;
                result.$query = $$query.bind(result.$_collection);
                result.$all = $$all.bind(result.$_collection);
                result.$add = $$add;
                result.$more = $$more;
                result.$nextPage = $$nextPage;
                result.$prevPage = $$prevPage;
                result.$totalCount = result.$_collection.length;
                result.$toJSON = $$toJSON;
            },
            addFrameworkMethodsToNestedCollection: function(result) {
                result.$fetch = $fetchRelatedEntities.bind(result);
                result.$query = $$query.bind(result.$_collection);
                result.$all = $$all.bind(result.$_collection);
                result.$more = $$more;
                result.$nextPage = $$nextPage;
                result.$prevPage = $$prevPage;
                result.$toJSON = $$toJSON;
                result.$isLoaded = function() {
                    return !!result.$_isLoaded;
                };
                result.$totalCount = null;
            },
            cleanNgWakEntityAfterSave: function(ngWakEntity) {
                var processedAttributes = ngWakEntity.$_entity.getDataClass().$_processedAttributes;
                if (processedAttributes.length > 0) processedAttributes.forEach(function(attr) {
                    if ("undefined" !== typeof ngWakEntity.$_entity[attr.name].$_tempValue) delete ngWakEntity.$_entity[attr.name].$_tempValue;
                });
            }
        };
        var $$create = function(pojo) {
            var i;
            var relatedAttributes = {};
            for (i = 0; i < this.$_relatedAttributes.length; i++) {
                var attr = this.$_relatedAttributes[i];
                if (pojo.hasOwnProperty(attr.name) && void 0 !== pojo[attr.name]) {
                    relatedAttributes[attr.name] = pojo[attr.name];
                    delete pojo[attr.name];
                }
            }
            var entity = createNgWakEntity(new WAF.Entity(this, pojo || {}), {
                expend: true
            });
            var keys = Object.keys(relatedAttributes);
            for (i = 0; i < keys.length; i++) entity[keys[i]] = relatedAttributes[keys];
            return entity;
        };
        var updateCollectionQueryInfos = function(resultSet, pageSize, start) {
            if ("undefined" === typeof resultSet.$queryParams) resultSet.$queryParams = {};
            resultSet.$queryParams.pageSize = pageSize;
            resultSet.$queryParams.start = start;
        };
        var updateQueryInfos = function(resultSet, pageSize, start, filter) {
            if ("undefined" === typeof resultSet.$queryParams) resultSet.$queryParams = {};
            resultSet.$queryParams.pageSize = pageSize;
            resultSet.$queryParams.start = start;
            resultSet.$queryParams.filter = filter ? filter : resultSet.$queryParams.filter;
        };
        var $$fetch = function(options, mode) {
            var deferred, wakOptions = {}, that = this, skip, top;
            mode = mode || "replace";
            if ("replace" !== mode && "append" !== mode) throw new Error("Unknow mode " + mode + ", mode must be replace or append.");
            if (!options) options = {};
            if ("undefined" !== typeof options.orderBy) throw new Error("orderBy can't be change on a $fetch (query collection's cached on server side)");
            if ("undefined" !== typeof options.select) throw new Error("select can't be change on a $fetch (query collection's cached on server side)");
            skip = options.start = "undefined" === typeof options.start ? this.$queryParams.start : options.start;
            top = options.pageSize = options.pageSize || this.$queryParams.pageSize;
            if (options.params) wakOptions.params = options.params;
            Object.defineProperty(this, "$fetching", {
                enumerable: false,
                writable: true,
                configurable: true
            });
            deferred = $q.defer();
            deferred.promise.$promise = deferred.promise;
            that = this;
            rootScopeSafeApply(function() {
                that.$fetching = true;
            });
            wakOptions.onSuccess = function(event) {
                rootScopeSafeApply(function() {
                    if ("replace" === mode) that.length = 0;
                    event.entities.forEach(function(entity, i) {
                        var ngWakEntity = createNgWakEntity(entity, {
                            expend: true
                        });
                        if ("replace" === mode) that[i] = ngWakEntity; else if ("append" === mode) that.push(ngWakEntity); else throw new Error("Unknow mode " + mode + ", mode must be replace or append.");
                    });
                    updateQueryInfos(that, options.pageSize || that.$_collection._private.pageSize, skip);
                    that.$fetching = false;
                    deferred.resolve(event);
                });
            };
            wakOptions.onError = function(event) {
                rootScopeSafeApply(function() {
                    console.error("$fetch > getEntities > onError", event);
                    that.$fetching = false;
                    deferred.reject(event);
                });
            };
            this.$_collection.getEntities(skip, top, wakOptions);
            return deferred.promise;
        };
        var $$toJSON = function() {
            return JSON.stringify(this);
        };
        var $$more = function() {
            var start, pageSize, totalCount, deferred;
            if ("undefined" !== typeof this.$queryParams) {
                start = this.$queryParams.start + this.$queryParams.pageSize;
                pageSize = this.$queryParams.pageSize;
                totalCount = this.$totalCount;
            } else {
                start = 0;
                pageSize = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
                totalCount = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
            }
            if (start >= totalCount) {
                deferred = new $q.defer();
                deferred.promise.$promise = deferred.promise;
                deferred.resolve({
                    noMore: true
                });
                return deferred.promise;
            } else return this.$fetch({
                start: start,
                pageSize: pageSize
            }, "append");
        };
        var $$nextPage = function() {
            var start, pageSize, totalCount, deferred;
            if ("undefined" !== typeof this.$queryParams) {
                start = this.$queryParams.start + this.$queryParams.pageSize;
                pageSize = this.$queryParams.pageSize;
                totalCount = this.$totalCount;
            } else {
                start = 0;
                pageSize = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
                totalCount = DEFAULT_PAGESIZE_NESTED_COLLECTIONS;
            }
            if (start >= totalCount) {
                deferred = new $q.defer();
                deferred.promise.$promise = deferred.promise;
                deferred.resolve({
                    noMore: true
                });
                return deferred.promise;
            } else return this.$fetch({
                start: start,
                pageSize: pageSize
            });
        };
        var $$prevPage = function() {
            var start, pageSize, deferred, noMore;
            if ("undefined" !== typeof this.$queryParams) {
                start = this.$queryParams.start - this.$queryParams.pageSize;
                pageSize = this.$queryParams.pageSize;
            } else {
                deferred = new $q.defer();
                deferred.promise.$promise = deferred.promise;
                deferred.reject(new Error("No collection fetched to $prevPage() on."));
                console.error("No collection fetched to $prevPage() on.");
                return deferred.promise;
            }
            deferred = new $q.defer();
            deferred.promise.$promise = deferred.promise;
            if (start < 0) {
                noMore = true;
                start = 0;
            }
            this.$fetch({
                start: start,
                pageSize: pageSize
            }).$promise.then(function(e) {
                if (true === noMore) e.noMore = true;
                deferred.resolve(e);
            })["catch"](function(e) {
                deferred.reject(e);
            });
            return deferred.promise;
        };
        var $$add = function() {
            console.log("$add method not yet implemented");
        };
        var $$query = function(options) {
            var wakOptions = {}, result = [], deferred;
            options = "object" === typeof options && options || {};
            if (options.select) wakOptions.autoExpand = options.select;
            [ "params", "orderBy", "pageSize" ].forEach(function(opt) {
                if (void 0 !== options[opt]) wakOptions[opt] = options[opt];
            });
            deferred = $q.defer();
            result.$promise = deferred.promise;
            Object.defineProperty(result, "$fetching", {
                enumerable: false,
                writable: true,
                configurable: true
            });
            rootScopeSafeApply(function() {
                result.$fetching = true;
            });
            wakOptions.onSuccess = function(event) {
                rootScopeSafeApply(function() {
                    transform.wafEntityCollectionToNgWakEntityCollection(result, event.result, wakOptions);
                    updateQueryInfos(result, result.$_collection._private.pageSize, 0, options.query);
                    result.$fetching = false;
                    event.result = result;
                    deferred.resolve(event);
                });
            };
            wakOptions.onError = function(event) {
                rootScopeSafeApply(function() {
                    console.error("$query > query > onError", event);
                    result.$fetching = false;
                    deferred.reject(event);
                });
            };
            this.query(options.filter || null, wakOptions);
            return result;
        };
        var $$all = function(options) {
            options = "object" === typeof options && options || {};
            if (options.filter) console.warn("filter parameter on options object is not allowed on calling $all() method. It will be ignored");
            options.filter = null;
            return this.$query(options);
        };
        var $$find = function(key, options) {
            var wakOptions = {}, deferred = $q.defer(), ngWakEntity = createNgWakEntity(new WAF.Entity(this, {}));
            options = "object" === typeof options && options || {};
            wakOptions.forceReload = "undefined" === typeof options.forceReload ? true : options.forceReload;
            wakOptions.autoExpand = options && options.select || void 0;
            ngWakEntity.$promise = deferred.promise;
            Object.defineProperty(ngWakEntity, "$fetching", {
                enumerable: false,
                writable: true,
                configurable: true
            });
            ngWakEntity.$fetching = true;
            wakOptions.onSuccess = function(event) {
                rootScopeSafeApply(function() {
                    ngWakEntity.$_entity = event.entity;
                    delete ngWakEntity.$_key;
                    ngWakEntity.$fetching = false;
                    event.result = ngWakEntity;
                    deferred.resolve(event);
                });
            };
            wakOptions.onError = function(event) {
                rootScopeSafeApply(function() {
                    console.error("$find > getEntity > error", event);
                    ngWakEntity.$fetching = false;
                    deferred.reject(event);
                });
            };
            this.getEntity(key, wakOptions);
            return ngWakEntity;
        };
        var NgWakEntityAbstractPrototype = {
            init: function() {
                var dataClass;
                if (arguments[0] instanceof WAF.Entity) {
                    this.$_entity = arguments[0];
                    dataClass = this.$_entity.getDataClass();
                } else if (arguments[0] instanceof WAF.DataClass && "undefined" !== typeof arguments[1]) {
                    this.$_key = arguments[1];
                    dataClass = arguments[0];
                }
                this.$_dataClass = dataClass;
                Object.defineProperty(this, "$_dataClass", {
                    enumerable: false,
                    configurable: false,
                    writable: false
                });
                Object.defineProperty(this, "$_entity", {
                    enumerable: false,
                    configurable: false,
                    writable: true
                });
                dataClass.getAttributes().forEach(function(attr) {
                    if ("relatedEntity" === attr.kind) Object.defineProperty(this, attr.name, {
                        enumerable: true,
                        configurable: true,
                        get: function() {
                            return getRelatedEntity(this, attr.name);
                        },
                        set: function(ngWakEntity) {
                            if (this.$_entity) rootScopeSafeApply(function() {
                                this.$_entity[attr.name].setValue(ngWakEntity.$_entity);
                                this[attr.name].$_entity = ngWakEntity.$_entity;
                            }.bind(this));
                        }
                    }); else if ("relatedEntities" === attr.kind) Object.defineProperty(this, attr.name, {
                        enumerable: !!this.$_entity,
                        configurable: true,
                        get: function() {
                            if (!this._related) Object.defineProperty(this, "_related", {
                                value: {},
                                enumerable: false,
                                writable: true,
                                configurable: true
                            });
                            if (this._related[attr.name]) return this._related[attr.name];
                            var result = [];
                            if (!this.$_entity) throw new Error("Can't get relatedEntities '" + attr.name + "' before fetching the entity, please use $fetch before !");
                            result.$_collection = this.$_entity[attr.name];
                            transform.addFrameworkMethodsToNestedCollection(result);
                            if (this.$_entity[attr.name].value.__ENTITIES) result.$fetch();
                            this._related[attr.name] = result;
                            return result;
                        },
                        set: function() {
                            throw new Error("Can't set relatedEntities attribute " + attr.name + ".");
                        }
                    }); else if ("calculated" === attr.kind || "alias" === attr.kind) Object.defineProperty(this, attr.name, {
                        enumerable: true,
                        configurable: true,
                        get: function() {
                            if (this.$_entity) return this.$_entity[attr.name].getValue();
                        },
                        set: function(newValue) {
                            if (this.$_entity) if (true !== attr.readOnly) rootScopeSafeApply(function() {
                                this.$_entity[attr.name].setValue(newValue);
                            }.bind(this)); else throw new Error("Attribute " + attr.name + " is readOnly (you may want to declare a setter server-side).");
                        }
                    }); else if ("image" === attr.type) {
                        var that = this;
                        var value = {};
                        Object.defineProperty(this, attr.name, {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                var attribute = that.$_entity[attr.name];
                                if (!attribute.resolvedID) {
                                    var val = attribute.getValue();
                                    if (val) value.__deferred = angular.extend({}, val.__deferred); else delete value.__deferred;
                                }
                                return value;
                            },
                            set: function(value) {
                                var attribute = that.$_entity[attr.name];
                                attribute.setValue(value);
                            }
                        });
                        Object.defineProperty(value, "uri", {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                return this.__deferred && this.__deferred.uri;
                            },
                            set: function(value) {
                                throw new Error("Attribute " + attr.name + " is an image, your must use $upload method or assign the value directly to the attribute.");
                            }
                        });
                        value.$upload = function(file) {
                            var deferred = $q.defer(), wakOptions = {
                                onSuccess: function(e) {
                                    deferred.resolve(e);
                                },
                                onError: function(e) {
                                    deferred.reject(e);
                                },
                                timeout: 300
                            }, attribute = that.$_entity[attr.name];
                            deferred.promise.$promise = deferred.promise;
                            if (file) attribute.setValue(file); else if (!attribute.unResolvedFile) throw new Error("there is no file to upload !");
                            attribute.resolveFile(wakOptions);
                            var reader = new FileReader();
                            reader.readAsDataURL(file);
                            reader.onloadend = function(e) {
                                if (!value.__deferred) value.__deferred = {};
                                value.__deferred.uri = reader.result;
                            };
                            return deferred.promise;
                        };
                    } else if ("object" === attr.type && "storage" === attr.kind) {
                        if (!("object" === typeof this.$_objectAttributesOriginalValueStr)) this.$_objectAttributesOriginalValueStr = {};
                        this.$_objectAttributesOriginalValueStr[attr.name] = JSON.stringify(this.$_entity[attr.name].getValue());
                        Object.defineProperty(this, attr.name, {
                            enumerable: true,
                            configurable: true,
                            get: function() {
                                if (this.$_entity) return this.$_entity[attr.name].getValue();
                            },
                            set: function(newValue) {
                                if (this.$_entity) rootScopeSafeApply(function() {
                                    this.$_entity[attr.name].setValue(newValue);
                                }.bind(this));
                            }
                        });
                    } else Object.defineProperty(this, attr.name, {
                        enumerable: true,
                        configurable: true,
                        get: function() {
                            if (this.$_entity) return this.$_entity[attr.name].getValue();
                        },
                        set: function(newValue) {
                            if (this.$_entity) rootScopeSafeApply(function() {
                                this.$_entity[attr.name].setValue(newValue);
                            }.bind(this));
                        }
                    });
                }.bind(this));
            },
            $key: function() {
                if (this.$_entity) return this.$_entity.getKey(); else if (this.$_key) return this.$_key;
            },
            $stamp: function() {
                if (this.$_entity) return this.$_entity.getStamp();
            },
            $isNew: function() {
                if (this.$_entity) return this.$_entity.isNew();
            },
            $save: function() {
                if (!this.$_entity) throw new Error("Can't $save() without pointer, please $fetch() before.");
                var _this = this;
                this.$_dataClass.getAttributes().forEach(function(attr) {
                    if ("object" === attr.type && "storage" === attr.kind && false === _this.$_entity[attr.name].isTouched()) if (_this.$_objectAttributesOriginalValueStr[attr.name] !== JSON.stringify(_this.$_entity[attr.name].value)) _this.$_entity[attr.name].touch();
                });
                console.group("$save");
                var deferred, wakOptions = {}, that = this;
                deferred = $q.defer();
                deferred.promise.$promise = deferred.promise;
                wakOptions.onSuccess = function(event) {
                    rootScopeSafeApply(function() {
                        console.log("save.onSuccess", "event", event);
                        transform.cleanNgWakEntityAfterSave(that);
                        deferred.resolve(event);
                    });
                };
                wakOptions.onError = function(error) {
                    rootScopeSafeApply(function() {
                        console.error("save.onError", "error", error);
                        deferred.reject(error);
                    });
                };
                this.$_entity.save(wakOptions);
                console.groupEnd();
                return deferred.promise;
            },
            $remove: function() {
                if (!this.$_entity) throw new Error("Can't $remove() without pointer, please $fetch() before.");
                console.group("$remove");
                var deferred, wakOptions = {}, that = this;
                deferred = $q.defer();
                deferred.promise.$promise = deferred.promise;
                wakOptions.onSuccess = function(event) {
                    rootScopeSafeApply(function() {
                        console.log("remove.onSuccess", "event", event);
                        deferred.resolve(event);
                    });
                };
                wakOptions.onError = function(error) {
                    rootScopeSafeApply(function() {
                        console.error("remove.onError", "error", error);
                        deferred.reject(error);
                    });
                };
                this.$_entity.remove(wakOptions);
                console.groupEnd();
                return deferred.promise;
            },
            $fetch: function(options) {
                var key, deferred, wakOptions = {}, dataClass;
                options = "undefined" === typeof options ? {} : options;
                if (!this.$key()) throw new Error("$fetch error - no key nor pointer was found");
                key = this.$key();
                deferred = $q.defer();
                deferred.promise.$promise = deferred.promise;
                var that = this;
                Object.defineProperty(that, "$fetching", {
                    enumerable: false,
                    writable: true,
                    configurable: true
                });
                rootScopeSafeApply(function() {
                    that.$fetching = true;
                });
                wakOptions.onSuccess = function(event) {
                    rootScopeSafeApply(function() {
                        that.$_entity = event.entity;
                        delete that.$_key;
                        that.$fetching = false;
                        event.result = that;
                        that.$_dataClass.$_relatedAttributes.forEach(function(attr) {
                            if ("relatedEntities" === attr.kind) Object.defineProperty(that, attr.name, {
                                enumerable: true
                            });
                        });
                        deferred.resolve(event);
                    });
                };
                wakOptions.onError = function(event) {
                    rootScopeSafeApply(function() {
                        that.$fetching = false;
                        deferred.resolve(event);
                    });
                };
                wakOptions.forceReload = "undefined" === typeof options.forceReload ? true : options.forceReload;
                this.$_dataClass.getEntity(key, wakOptions);
                return deferred.promise;
            },
            $isLoaded: function() {
                if (this.$_entity) return true; else return false;
            },
            $toJSON: $$toJSON,
            $serverRefresh: function(options) {
                var deferred = $q.defer(), that = this;
                options = options || {};
                deferred.promise.$promise = deferred.promise;
                if (!this.$_entity) throw new Error("Can't $serverRefresh() without pointer, please $fetch() before.");
                var wakOptions = {
                    onSuccess: function(e) {
                        rootScopeSafeApply(function() {
                            deferred.resolve(e);
                        });
                    },
                    onError: function(e) {
                        rootScopeSafeApply(function() {
                            console.error("serverRefresh.error", e);
                            deferred.reject(e);
                        });
                    }
                };
                if (void 0 !== options.forceReload) wakOptions.forceReload = options.forceReload;
                this.$_entity.serverRefresh(wakOptions);
                return deferred.promise;
            },
            toJSON: function() {
                var ret = {};
                for (var i = 0; i < this.$_dataClass._private.attributes.length; i++) {
                    var attrMeta = this.$_dataClass._private.attributes[i];
                    var attr = this.$_entity[attrMeta.name];
                    switch (attrMeta.kind) {
                      case "relatedEntity":
                        if ("string" === typeof this[attrMeta.name].$_key) ret[attrMeta.name] = {
                            ID: parseInt(attr.relKey)
                        }; else if (null === this[attrMeta.name].$_key) ret[attrMeta.name] = null; else ret[attrMeta.name] = this[attrMeta.name];
                        break;

                      default:
                        ret[attrMeta.name] = this[attrMeta.name];
                    }
                }
                return ret;
            }
        };
        var NgWakEntityAbstract = Class.extend(NgWakEntityAbstractPrototype);
        function getRelatedEntity(ngEntity, attr) {
            var dataClass = ngEntity.$_entity.getDataClass();
            if ("relatedEntity" !== dataClass.getAttributeByName(attr).kind || !ngEntity.$_entity || !ngEntity.$_entity[attr]) return;
            if (!ngEntity._related) Object.defineProperty(ngEntity, "_related", {
                value: {},
                enumerable: false,
                writable: true,
                configurable: true
            });
            if (!ngEntity._related[attr]) if (ngEntity.$_entity[attr].relEntity) {
                var wafEntity = ngEntity.$_entity[attr].relEntity;
                ngEntity._related[attr] = new (NgWakEntityClasses[wafEntity.getDataClass().getName()])(wafEntity);
            } else {
                dataClass = ngEntity.$_entity[attr].att.getRelatedClass();
                ngEntity._related[attr] = new (NgWakEntityClasses[dataClass.getName()])(dataClass, ngEntity.$_entity[attr].getRelatedKey());
            }
            return ngEntity._related[attr];
        }
        function createNgWakEntity(wafEntity, options) {
            var name, ngWakEntity;
            options = options || {};
            name = wafEntity.getDataClass().getName();
            ngWakEntity = new NgWakEntityClasses[name](wafEntity, options.key);
            if (!options.expend) return ngWakEntity;
            ngWakEntity.$_dataClass.$_relatedAttributes.forEach(function(attr) {
                if ("relatedEntity" !== attr.kind || !ngWakEntity.$_entity[attr.name]) return;
                getRelatedEntity(ngWakEntity, attr.name);
            });
            return ngWakEntity;
        }
        var $fetchRelatedEntities = function(options, mode) {
            var wakOptions = {}, deferred, that = this;
            mode = mode || "replace";
            options = options || {};
            deferred = $q.defer();
            deferred.promise.$promise = deferred.promise;
            wakOptions.skip = options.start = "undefined" === typeof options.start ? this.$queryParams ? this.$queryParams.start : 0 : options.start;
            wakOptions.top = options.pageSize = "undefined" === typeof options.pageSize ? this.$queryParams ? this.$queryParams.pageSize : DEFAULT_PAGESIZE_NESTED_COLLECTIONS : options.pageSize;
            if (void 0 !== options.select) {
                wakOptions.autoExpand = options.select;
                console.warn("select can't be change on a $fetch (query collection's cached on server side in some way)");
            }
            if (options.orderBy) {
                wakOptions.orderby = options.orderBy;
                console.warn("orderBy can't be change on a $fetch (nested query collection's cached on server side in some way)");
            }
            Object.defineProperty(that, "$fetching", {
                enumerable: false,
                writable: true,
                configurable: true
            });
            rootScopeSafeApply(function() {
                that.$fetching = true;
            });
            wakOptions.onSuccess = function(e) {
                rootScopeSafeApply(function() {
                    if ("replace" === mode) that.length = 0;
                    e.entityCollection.forEach({
                        onSuccess: function(item) {
                            var ngWakEntity = createNgWakEntity(item.entity, {
                                expend: true
                            });
                            rootScopeSafeApply(function() {
                                that.push(ngWakEntity);
                            });
                        },
                        first: wakOptions.skip,
                        limit: wakOptions.skip + wakOptions.top
                    });
                    that.$_isLoaded = true;
                    updateCollectionQueryInfos(that, options.pageSize, options.start);
                    that.$totalCount = e.entityCollection.length;
                    that.$fetching = false;
                    deferred.resolve(that);
                });
            };
            wakOptions.onError = function(event) {
                rootScopeSafeApply(function() {
                    console.error("$fetch (nestedEntities) ) > onError", event);
                    that.$fetching = false;
                    deferred.reject(event);
                });
            };
            that.$_collection.getValue(wakOptions);
            return deferred.promise;
        };
        return $wakandaResult;
    } ]);
})({}, function() {
    return this;
}());
//# sourceMappingURL=angular-wakanda.debug.min.js.map